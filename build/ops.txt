def abbr(value, limit):
    value :: object
    limit :: int
    r0, rep :: str
    r1 :: native_int
    r2 :: bit
    r3 :: short_int
    r4 :: native_int
    r5 :: bit
    r6 :: native_int
    r7, r8, r9 :: bit
    r10 :: native_int
    r11 :: bit
    r12 :: native_int
    r13, r14, r15 :: bit
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: int
    r24 :: object
    r25, r26, r27, r28 :: str
L0:
    if is_error(limit) goto L1 else goto L22
L1:
    limit = 158
L2:
    r0 = PyObject_Repr(value)
    if is_error(r0) goto L23 (error at abbr:11) else goto L3
L3:
    rep = r0
    r1 = CPyStr_Size_size_t(rep)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at abbr:13) else goto L4 :: bool
L4:
    r3 = r1 << 1
    r4 = r3 & 1
    r5 = r4 != 0
    if r5 goto L6 else goto L5 :: bool
L5:
    r6 = limit & 1
    r7 = r6 != 0
    if r7 goto L6 else goto L7 :: bool
L6:
    r8 = CPyTagged_IsLt_(limit, r3)
    if r8 goto L8 else goto L25 :: bool
L7:
    r9 = r3 > limit :: signed
    if r9 goto L8 else goto L25 :: bool
L8:
    r10 = limit & 1
    r11 = r10 != 0
    if r11 goto L10 else goto L9 :: bool
L9:
    r12 = 6 & 1
    r13 = r12 != 0
    if r13 goto L10 else goto L11 :: bool
L10:
    r14 = CPyTagged_IsLt_(limit, 6)
    if r14 goto L26 else goto L16 :: bool
L11:
    r15 = limit < 6 :: signed
    if r15 goto L26 else goto L16 :: bool
L12:
    r16 = 'Abbreviation limit may not be less than 3'
    r17 = builtins :: module
    r18 = 'ValueError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L21 (error at abbr:15) else goto L13
L13:
    r20 = [r16]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L21 (error at abbr:15) else goto L14
L14:
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L21 (error at abbr:15) else goto L15 :: bool
L15:
    unreachable
L16:
    r23 = CPyTagged_Subtract(limit, 6)
    dec_ref limit :: int
    r24 = CPyStr_GetSlice(rep, 0, r23)
    dec_ref rep
    dec_ref r23 :: int
    if is_error(r24) goto L21 (error at abbr:17) else goto L17
L17:
    r25 = cast(str, r24)
    if is_error(r25) goto L21 (error at abbr:17) else goto L18
L18:
    r26 = '...'
    r27 = PyUnicode_Concat(r25, r26)
    dec_ref r25
    if is_error(r27) goto L21 (error at abbr:17) else goto L19
L19:
    rep = r27
L20:
    return rep
L21:
    r28 = <error> :: str
    return r28
L22:
    inc_ref limit :: int
    goto L2
L23:
    dec_ref limit :: int
    goto L21
L24:
    dec_ref limit :: int
    dec_ref rep
    goto L21
L25:
    dec_ref limit :: int
    goto L20
L26:
    dec_ref limit :: int
    dec_ref rep
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.string.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def encode_tuple(values, encoders):
    values, encoders :: object
    r0, r1 :: list
    r2, r3, r4, r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: bytes
    r19 :: i32
    r20 :: bit
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: bytes
    r25 :: i32
    r26 :: bit
    r27 :: bytes
    r28 :: i32
    r29, r30, r31 :: bit
    r32 :: int
    r33 :: native_int
    r34 :: ptr
    r35 :: native_int
    r36 :: bit
    r37, r38 :: ptr
    r39 :: native_int
    r40 :: ptr
    r41 :: object
    r42 :: union[bytes, None]
    r43 :: object
    r44 :: bit
    r45 :: int
    r46 :: bytes
    r47 :: ptr
    r48 :: native_int
    r49 :: short_int
    r50 :: int
    r51 :: native_int
    head_length :: int
    r52 :: object
    r53 :: list
    r54 :: ptr
    r55 :: native_int
    r56 :: list
    r57 :: native_int
    r58 :: ptr
    r59 :: native_int
    r60 :: bit
    r61, r62 :: ptr
    r63 :: native_int
    r64 :: ptr
    r65 :: object
    r66 :: bytes
    r67 :: ptr
    r68 :: native_int
    r69 :: short_int
    r70 :: object
    r71 :: native_int
    r72 :: object
    r73 :: dict
    r74 :: str
    r75 :: object
    r76 :: object[1]
    r77 :: object_ptr
    r78 :: object
    r79 :: list
    r80 :: object
    r81, r82 :: ptr
    r83 :: object
    r84 :: tuple
    r85 :: list
    r86 :: native_int
    r87 :: ptr
    r88, r89 :: native_int
    r90 :: ptr
    r91 :: native_int
    r92, r93 :: bit
    r94, r95 :: ptr
    r96 :: native_int
    r97 :: ptr
    r98 :: object
    r99 :: union[bytes, None]
    r100 :: object
    r101 :: int
    r102 :: object
    r103 :: bit
    r104 :: int
    r105, r106, r107 :: bytes
    r108 :: i32
    r109 :: bit
    r110, r111 :: native_int
    r112 :: tuple
    r113, r114, r115, r116, r117, r118 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L60 (error at encode_tuple:27) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L61 (error at encode_tuple:28) else goto L2
L2:
    r2 = PyObject_GetIter(values)
    if is_error(r2) goto L62 (error at encode_tuple:29) else goto L3
L3:
    r3 = PyObject_GetIter(encoders)
    if is_error(r3) goto L63 (error at encode_tuple:29) else goto L4
L4:
    r4 = PyIter_Next(r2)
    if is_error(r4) goto L64 else goto L5
L5:
    r5 = PyIter_Next(r3)
    if is_error(r5) goto L65 else goto L6
L6:
    r6 = 'is_dynamic'
    r7 = box(bool, 0)
    r8 = CPyObject_GetAttr3(r5, r6, r7)
    if is_error(r8) goto L66 (error at encode_tuple:30) else goto L7
L7:
    r9 = PyObject_IsTrue(r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L66 (error at encode_tuple:30) else goto L8 :: bool
L8:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L9 else goto L13 :: bool
L9:
    r12 = box(None, 1)
    r13 = PyList_Append(r0, r12)
    r14 = r13 >= 0 :: signed
    if not r14 goto L66 (error at encode_tuple:31) else goto L10 :: bool
L10:
    r15 = [r4]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r5, r16, 1, 0)
    dec_ref r5
    if is_error(r17) goto L67 (error at encode_tuple:32) else goto L11
L11:
    dec_ref r4
    r18 = cast(bytes, r17)
    if is_error(r18) goto L68 (error at encode_tuple:32) else goto L12
L12:
    r19 = PyList_Append(r1, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L68 (error at encode_tuple:32) else goto L4 :: bool
L13:
    r21 = [r4]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r5, r22, 1, 0)
    dec_ref r5
    if is_error(r23) goto L67 (error at encode_tuple:34) else goto L14
L14:
    dec_ref r4
    r24 = cast(bytes, r23)
    if is_error(r24) goto L68 (error at encode_tuple:34) else goto L15
L15:
    r25 = PyList_Append(r0, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L68 (error at encode_tuple:34) else goto L16 :: bool
L16:
    r27 = b''
    r28 = PyList_Append(r1, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L68 (error at encode_tuple:35) else goto L4 :: bool
L17:
    r30 = CPy_NoErrOccurred()
    if not r30 goto L62 (error at encode_tuple:29) else goto L18 :: bool
L18:
    r31 = CPy_NoErrOccurred()
    if not r31 goto L62 (error at encode_tuple:29) else goto L19 :: bool
L19:
    r32 = 0
    r33 = 0
L20:
    r34 = get_element_ptr r0 ob_size :: PyVarObject
    r35 = load_mem r34 :: native_int*
    r36 = r33 < r35 :: signed
    if r36 goto L21 else goto L28 :: bool
L21:
    r37 = get_element_ptr r0 ob_item :: PyListObject
    r38 = load_mem r37 :: ptr*
    r39 = r33 * 8
    r40 = r38 + r39
    r41 = load_mem r40 :: builtins.object*
    r42 = cast(union[bytes, None], r41)
    if is_error(r42) goto L69 (error at encode_tuple:37) else goto L22
L22:
    r43 = load_address _Py_NoneStruct
    r44 = r42 == r43
    if r44 goto L70 else goto L24 :: bool
L23:
    r45 = 64
    goto L26
L24:
    r46 = cast(bytes, r42)
    if is_error(r46) goto L69 (error at encode_tuple:37) else goto L25
L25:
    r47 = get_element_ptr r46 ob_size :: PyVarObject
    r48 = load_mem r47 :: native_int*
    dec_ref r46
    r49 = r48 << 1
    r45 = r49
L26:
    r50 = CPyTagged_Add(r32, r45)
    dec_ref r32 :: int
    dec_ref r45 :: int
    r32 = r50
L27:
    r51 = r33 + 1
    r33 = r51
    goto L20
L28:
    head_length = r32
    r52 = CPyList_GetSlice(r1, 0, -2)
    if is_error(r52) goto L71 (error at encode_tuple:38) else goto L29
L29:
    r53 = cast(list, r52)
    if is_error(r53) goto L71 (error at encode_tuple:38) else goto L30
L30:
    r54 = get_element_ptr r53 ob_size :: PyVarObject
    r55 = load_mem r54 :: native_int*
    r56 = PyList_New(r55)
    if is_error(r56) goto L72 (error at encode_tuple:38) else goto L31
L31:
    r57 = 0
L32:
    r58 = get_element_ptr r53 ob_size :: PyVarObject
    r59 = load_mem r58 :: native_int*
    r60 = r57 < r59 :: signed
    if r60 goto L33 else goto L73 :: bool
L33:
    r61 = get_element_ptr r53 ob_item :: PyListObject
    r62 = load_mem r61 :: ptr*
    r63 = r57 * 8
    r64 = r62 + r63
    r65 = load_mem r64 :: builtins.object*
    r66 = cast(bytes, r65)
    if is_error(r66) goto L74 (error at encode_tuple:38) else goto L34
L34:
    r67 = get_element_ptr r66 ob_size :: PyVarObject
    r68 = load_mem r67 :: native_int*
    dec_ref r66
    r69 = r68 << 1
    r70 = box(short_int, r69)
    CPyList_SetItemUnsafe(r56, r57, r70)
L35:
    r71 = r57 + 1
    r57 = r71
    goto L32
L36:
    r72 = PyObject_GetIter(r56)
    dec_ref r56
    if is_error(r72) goto L71 (error at encode_tuple:38) else goto L37
L37:
    r73 = faster_eth_abi._encoding.globals :: static
    r74 = 'accumulate'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L75 (error at encode_tuple:38) else goto L38
L38:
    r76 = [r72]
    r77 = load_address r76
    r78 = PyObject_Vectorcall(r75, r77, 1, 0)
    dec_ref r75
    if is_error(r78) goto L75 (error at encode_tuple:38) else goto L39
L39:
    dec_ref r72
    r79 = PyList_New(1)
    if is_error(r79) goto L76 (error at encode_tuple:38) else goto L40
L40:
    r80 = object 0
    r81 = get_element_ptr r79 ob_item :: PyListObject
    r82 = load_mem r81 :: ptr*
    inc_ref r80
    set_mem r82, r80 :: builtins.object*
    r83 = CPyList_Extend(r79, r78)
    dec_ref r78
    if is_error(r83) goto L77 (error at encode_tuple:38) else goto L78
L41:
    r84 = PyList_AsTuple(r79)
    dec_ref r79
    if is_error(r84) goto L71 (error at encode_tuple:38) else goto L42
L42:
    r85 = PyList_New(0)
    if is_error(r85) goto L79 (error at encode_tuple:39) else goto L43
L43:
    r86 = 0
    r87 = get_element_ptr r84 ob_size :: PyVarObject
    r88 = load_mem r87 :: native_int*
    r89 = 0
L44:
    r90 = get_element_ptr r0 ob_size :: PyVarObject
    r91 = load_mem r90 :: native_int*
    r92 = r86 < r91 :: signed
    if r92 goto L45 else goto L80 :: bool
L45:
    r93 = r89 < r88 :: signed
    if r93 goto L46 else goto L80 :: bool
L46:
    r94 = get_element_ptr r0 ob_item :: PyListObject
    r95 = load_mem r94 :: ptr*
    r96 = r86 * 8
    r97 = r95 + r96
    r98 = load_mem r97 :: builtins.object*
    r99 = cast(union[bytes, None], r98)
    if is_error(r99) goto L81 (error at encode_tuple:39) else goto L47
L47:
    r100 = CPySequenceTuple_GetItemUnsafe(r84, r89)
    r101 = unbox(int, r100)
    dec_ref r100
    if is_error(r101) goto L82 (error at encode_tuple:39) else goto L48
L48:
    r102 = load_address _Py_NoneStruct
    r103 = r99 == r102
    if r103 goto L83 else goto L84 :: bool
L49:
    r104 = CPyTagged_Add(head_length, r101)
    dec_ref r101 :: int
    r105 = encode_uint_256(r104)
    dec_ref r104 :: int
    if is_error(r105) goto L81 (error at encode_tuple:40) else goto L50
L50:
    r106 = r105
    goto L53
L51:
    r107 = cast(bytes, r99)
    if is_error(r107) goto L81 (error at encode_tuple:40) else goto L52
L52:
    r106 = r107
L53:
    r108 = PyList_Append(r85, r106)
    dec_ref r106
    r109 = r108 >= 0 :: signed
    if not r109 goto L81 (error at encode_tuple:39) else goto L54 :: bool
L54:
    r110 = r86 + 1
    r86 = r110
    r111 = r89 + 1
    r89 = r111
    goto L44
L55:
    r112 = PyList_AsTuple(r85)
    dec_ref r85
    if is_error(r112) goto L85 (error at encode_tuple:39) else goto L56
L56:
    r113 = b''
    r114 = CPyBytes_Join(r113, r112)
    dec_ref r112
    if is_error(r114) goto L85 (error at encode_tuple:44) else goto L57
L57:
    r115 = b''
    r116 = CPyBytes_Join(r115, r1)
    dec_ref r1
    if is_error(r116) goto L86 (error at encode_tuple:44) else goto L58
L58:
    r117 = CPyBytes_Concat(r114, r116)
    dec_ref r116
    if is_error(r117) goto L60 (error at encode_tuple:44) else goto L59
L59:
    return r117
L60:
    r118 = <error> :: bytes
    return r118
L61:
    dec_ref r0
    goto L60
L62:
    dec_ref r0
    dec_ref r1
    goto L60
L63:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L60
L64:
    dec_ref r2
    dec_ref r3
    goto L17
L65:
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L17
L66:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    goto L60
L67:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L60
L68:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L60
L69:
    dec_ref r0
    dec_ref r1
    dec_ref r32 :: int
    goto L60
L70:
    dec_ref r42
    goto L23
L71:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    goto L60
L72:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r53
    goto L60
L73:
    dec_ref r53
    goto L36
L74:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r53
    dec_ref r56
    goto L60
L75:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r72
    goto L60
L76:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r78
    goto L60
L77:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r79
    goto L60
L78:
    dec_ref r83
    goto L41
L79:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r84
    goto L60
L80:
    dec_ref r0
    dec_ref head_length :: int
    dec_ref r84
    goto L55
L81:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r84
    dec_ref r85
    goto L60
L82:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r84
    dec_ref r85
    dec_ref r99
    goto L60
L83:
    dec_ref r99
    goto L49
L84:
    dec_ref r101 :: int
    goto L51
L85:
    dec_ref r1
    goto L60
L86:
    dec_ref r114
    goto L60

def encode_fixed(value, encode_fn, is_big_endian, data_byte_size):
    value, encode_fn :: object
    is_big_endian :: bool
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3, r4 :: bytes
    r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bytes
    r12 :: str
    r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L9 (error at encode_fixed:53) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L9 (error at encode_fixed:53) else goto L2
L2:
    if is_big_endian goto L3 else goto L6 :: bool
L3:
    r4 = b'\x00'
    r5 = 'rjust'
    inc_ref data_byte_size :: int
    r6 = box(int, data_byte_size)
    r7 = [r3, r6, r4]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r5, r8, 9223372036854775811, 0)
    if is_error(r9) goto L10 (error at encode_fixed:55) else goto L4
L4:
    dec_ref r3
    dec_ref r6
    r10 = cast(bytes, r9)
    if is_error(r10) goto L9 (error at encode_fixed:55) else goto L5
L5:
    return r10
L6:
    r11 = b'\x00'
    r12 = 'ljust'
    inc_ref data_byte_size :: int
    r13 = box(int, data_byte_size)
    r14 = [r3, r13, r11]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r12, r15, 9223372036854775811, 0)
    if is_error(r16) goto L11 (error at encode_fixed:57) else goto L7
L7:
    dec_ref r3
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at encode_fixed:57) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r3
    dec_ref r6
    goto L9
L11:
    dec_ref r3
    dec_ref r13
    goto L9

def encode_signed(value, encode_fn, data_byte_size):
    value, encode_fn :: object
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3 :: bytes
    r4, r5 :: object
    r6 :: bool
    r7 :: bytes
    r8 :: str
    r9 :: object
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: bytes
    r15 :: str
    r16 :: object
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L11 (error at encode_signed:65) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L11 (error at encode_signed:65) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(value, r4, 5)
    if is_error(r5) goto L12 (error at encode_signed:66) else goto L3
L3:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L12 (error at encode_signed:66) else goto L4
L4:
    if r6 goto L5 else goto L8 :: bool
L5:
    r7 = b'\x00'
    r8 = 'rjust'
    inc_ref data_byte_size :: int
    r9 = box(int, data_byte_size)
    r10 = [r3, r9, r7]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r8, r11, 9223372036854775811, 0)
    if is_error(r12) goto L13 (error at encode_signed:67) else goto L6
L6:
    dec_ref r3
    dec_ref r9
    r13 = cast(bytes, r12)
    if is_error(r13) goto L11 (error at encode_signed:67) else goto L7
L7:
    return r13
L8:
    r14 = b'\xff'
    r15 = 'rjust'
    inc_ref data_byte_size :: int
    r16 = box(int, data_byte_size)
    r17 = [r3, r16, r14]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r15, r18, 9223372036854775811, 0)
    if is_error(r19) goto L14 (error at encode_signed:69) else goto L9
L9:
    dec_ref r3
    dec_ref r16
    r20 = cast(bytes, r19)
    if is_error(r20) goto L11 (error at encode_signed:69) else goto L10
L10:
    return r20
L11:
    r21 = <error> :: bytes
    return r21
L12:
    dec_ref r3
    goto L11
L13:
    dec_ref r3
    dec_ref r9
    goto L11
L14:
    dec_ref r3
    dec_ref r16
    goto L11

def encode_elements(item_encoder, value):
    item_encoder, value :: object
    r0 :: list
    r1, r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bytes
    r7 :: i32
    r8, r9 :: bit
    r10 :: tuple
    r11 :: str
    r12, r13 :: object
    r14 :: bool
    r15 :: int
    r16 :: bit
    r17, r18 :: bytes
    r19, r20 :: int
    r21 :: object
    r22 :: tuple
    r23 :: ptr
    r24 :: native_int
    r25 :: list
    r26 :: ptr
    r27, r28 :: native_int
    r29 :: bit
    r30 :: object
    r31 :: bytes
    r32 :: ptr
    r33 :: native_int
    r34 :: short_int
    r35 :: object
    r36 :: native_int
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: list
    r45 :: object
    r46, r47 :: ptr
    r48 :: object
    r49 :: tuple
    r50 :: ptr
    r51 :: native_int
    r52 :: tuple
    r53 :: ptr
    r54, r55 :: native_int
    r56 :: bit
    r57 :: object
    r58, r59 :: int
    r60 :: bytes
    r61 :: native_int
    r62, r63, r64, r65, r66, r67 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L41 (error at encode_elements:73) else goto L1
L1:
    r1 = PyObject_GetIter(value)
    if is_error(r1) goto L42 (error at encode_elements:73) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L43 else goto L3
L3:
    r3 = [r2]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(item_encoder, r4, 1, 0)
    if is_error(r5) goto L44 (error at encode_elements:73) else goto L4
L4:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L45 (error at encode_elements:73) else goto L5
L5:
    r7 = PyList_Append(r0, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L45 (error at encode_elements:73) else goto L2 :: bool
L6:
    r9 = CPy_NoErrOccurred()
    if not r9 goto L42 (error at encode_elements:73) else goto L7 :: bool
L7:
    r10 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r10) goto L41 (error at encode_elements:73) else goto L8
L8:
    r11 = 'is_dynamic'
    r12 = box(bool, 0)
    r13 = CPyObject_GetAttr3(item_encoder, r11, r12)
    if is_error(r13) goto L46 (error at encode_elements:75) else goto L9
L9:
    r14 = unbox(bool, r13)
    dec_ref r13
    if is_error(r14) goto L46 (error at encode_elements:75) else goto L10
L10:
    if r14 goto L11 else goto L13 :: bool
L11:
    r15 = CPyObject_Size(value)
    if is_error(r15) goto L46 (error at encode_elements:76) else goto L12
L12:
    r16 = r15 == 0
    dec_ref r15 :: int
    if r16 goto L13 else goto L15 :: bool
L13:
    r17 = b''
    r18 = CPyBytes_Join(r17, r10)
    dec_ref r10
    if is_error(r18) goto L41 (error at encode_elements:77) else goto L14
L14:
    return r18
L15:
    r19 = CPyObject_Size(value)
    if is_error(r19) goto L46 (error at encode_elements:79) else goto L16
L16:
    r20 = CPyTagged_Multiply(64, r19)
    dec_ref r19 :: int
    r21 = CPySequenceTuple_GetSlice(r10, 0, -2)
    if is_error(r21) goto L47 (error at encode_elements:80) else goto L17
L17:
    r22 = cast(tuple, r21)
    if is_error(r22) goto L47 (error at encode_elements:80) else goto L18
L18:
    r23 = get_element_ptr r22 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    r25 = PyList_New(r24)
    if is_error(r25) goto L48 (error at encode_elements:80) else goto L19
L19:
    r26 = get_element_ptr r22 ob_size :: PyVarObject
    r27 = load_mem r26 :: native_int*
    r28 = 0
L20:
    r29 = r28 < r27 :: signed
    if r29 goto L21 else goto L49 :: bool
L21:
    r30 = CPySequenceTuple_GetItemUnsafe(r22, r28)
    r31 = cast(bytes, r30)
    if is_error(r31) goto L50 (error at encode_elements:80) else goto L22
L22:
    r32 = get_element_ptr r31 ob_size :: PyVarObject
    r33 = load_mem r32 :: native_int*
    dec_ref r31
    r34 = r33 << 1
    r35 = box(short_int, r34)
    CPyList_SetItemUnsafe(r25, r28, r35)
L23:
    r36 = r28 + 1
    r28 = r36
    goto L20
L24:
    r37 = PyObject_GetIter(r25)
    dec_ref r25
    if is_error(r37) goto L47 (error at encode_elements:80) else goto L25
L25:
    r38 = faster_eth_abi._encoding.globals :: static
    r39 = 'accumulate'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L51 (error at encode_elements:80) else goto L26
L26:
    r41 = [r37]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r40, r42, 1, 0)
    dec_ref r40
    if is_error(r43) goto L51 (error at encode_elements:80) else goto L27
L27:
    dec_ref r37
    r44 = PyList_New(1)
    if is_error(r44) goto L52 (error at encode_elements:80) else goto L28
L28:
    r45 = object 0
    r46 = get_element_ptr r44 ob_item :: PyListObject
    r47 = load_mem r46 :: ptr*
    inc_ref r45
    set_mem r47, r45 :: builtins.object*
    r48 = CPyList_Extend(r44, r43)
    dec_ref r43
    if is_error(r48) goto L53 (error at encode_elements:80) else goto L54
L29:
    r49 = PyList_AsTuple(r44)
    dec_ref r44
    if is_error(r49) goto L47 (error at encode_elements:80) else goto L30
L30:
    r50 = get_element_ptr r49 ob_size :: PyVarObject
    r51 = load_mem r50 :: native_int*
    r52 = PyTuple_New(r51)
    if is_error(r52) goto L55 (error at encode_elements:81) else goto L31
L31:
    r53 = get_element_ptr r49 ob_size :: PyVarObject
    r54 = load_mem r53 :: native_int*
    r55 = 0
L32:
    r56 = r55 < r54 :: signed
    if r56 goto L33 else goto L56 :: bool
L33:
    r57 = CPySequenceTuple_GetItemUnsafe(r49, r55)
    r58 = unbox(int, r57)
    dec_ref r57
    if is_error(r58) goto L57 (error at encode_elements:81) else goto L34
L34:
    r59 = CPyTagged_Add(r20, r58)
    dec_ref r58 :: int
    r60 = encode_uint_256(r59)
    dec_ref r59 :: int
    if is_error(r60) goto L57 (error at encode_elements:82) else goto L35
L35:
    CPySequenceTuple_SetItemUnsafe(r52, r55, r60)
L36:
    r61 = r55 + 1
    r55 = r61
    goto L32
L37:
    r62 = b''
    r63 = CPyBytes_Join(r62, r52)
    dec_ref r52
    if is_error(r63) goto L46 (error at encode_elements:84) else goto L38
L38:
    r64 = b''
    r65 = CPyBytes_Join(r64, r10)
    dec_ref r10
    if is_error(r65) goto L58 (error at encode_elements:84) else goto L39
L39:
    r66 = CPyBytes_Concat(r63, r65)
    dec_ref r65
    if is_error(r66) goto L41 (error at encode_elements:84) else goto L40
L40:
    return r66
L41:
    r67 = <error> :: bytes
    return r67
L42:
    dec_ref r0
    goto L41
L43:
    dec_ref r1
    goto L6
L44:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L41
L45:
    dec_ref r0
    dec_ref r1
    goto L41
L46:
    dec_ref r10
    goto L41
L47:
    dec_ref r10
    dec_ref r20 :: int
    goto L41
L48:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r22
    goto L41
L49:
    dec_ref r22
    goto L24
L50:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r22
    dec_ref r25
    goto L41
L51:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r37
    goto L41
L52:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r43
    goto L41
L53:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r44
    goto L41
L54:
    dec_ref r48
    goto L29
L55:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r49
    goto L41
L56:
    dec_ref r20 :: int
    dec_ref r49
    goto L37
L57:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r49
    dec_ref r52
    goto L41
L58:
    dec_ref r63
    goto L41

def encode_elements_dynamic(item_encoder, value):
    item_encoder, value :: object
    r0 :: int
    r1, r2, r3, r4 :: bytes
L0:
    r0 = CPyObject_Size(value)
    if is_error(r0) goto L5 (error at encode_elements_dynamic:88) else goto L1
L1:
    r1 = encode_uint_256(r0)
    dec_ref r0 :: int
    if is_error(r1) goto L5 (error at encode_elements_dynamic:88) else goto L2
L2:
    r2 = encode_elements(item_encoder, value)
    if is_error(r2) goto L6 (error at encode_elements_dynamic:89) else goto L3
L3:
    r3 = CPyBytes_Concat(r1, r2)
    dec_ref r2
    if is_error(r3) goto L5 (error at encode_elements_dynamic:90) else goto L4
L4:
    return r3
L5:
    r4 = <error> :: bytes
    return r4
L6:
    dec_ref r1
    goto L5

def encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = int_to_big_endian(i)
    if is_error(r0) goto L4 (error at encode_uint_256:97) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at encode_uint_256:98) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at encode_uint_256:98) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at int_to_big_endian:103) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at int_to_big_endian:103) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at int_to_big_endian:103) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at int_to_big_endian:103) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L10 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('accumulate',)
    r6 = 'itertools'
    r7 = faster_eth_abi._encoding.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L10 (error at <module>:1) else goto L4
L4:
    itertools = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Callable', 'List', 'Optional', 'Sequence', 'TypeVar')
    r10 = 'typing'
    r11 = faster_eth_abi._encoding.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L10 (error at <module>:4) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    if 0 goto L6 else goto L6 :: bool
L6:
    r13 = 'T'
    r14 = faster_eth_abi._encoding.globals :: static
    r15 = 'TypeVar'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L10 (error at <module>:20) else goto L7
L7:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L10 (error at <module>:20) else goto L8
L8:
    r20 = faster_eth_abi._encoding.globals :: static
    r21 = 'T'
    r22 = CPyDict_SetItem(r20, r21, r19)
    dec_ref r19
    r23 = r22 >= 0 :: signed
    if not r23 goto L10 (error at <module>:20) else goto L9 :: bool
L9:
    return 1
L10:
    r24 = <error> :: None
    return r24

def validate_bytes_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: str
    r11 :: object
    r12, r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: None
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L10 (error at validate_bytes_param:7) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(param, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L10 (error at validate_bytes_param:7) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L9 else goto L3 :: bool
L3:
    r9 = 'The `'
    r10 = '` value must be of bytes type. Got '
    r11 = CPy_TYPE(param)
    r12 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r12) goto L10 (error at validate_bytes_param:9) else goto L4
L4:
    r13 = CPyStr_Build(4, r9, param_name, r10, r12)
    dec_ref r12
    if is_error(r13) goto L10 (error at validate_bytes_param:9) else goto L5
L5:
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L11 (error at validate_bytes_param:8) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L11 (error at validate_bytes_param:8) else goto L7
L7:
    dec_ref r13
    CPy_Raise(r19)
    dec_ref r19
    if not 0 goto L10 (error at validate_bytes_param:8) else goto L8 :: bool
L8:
    unreachable
L9:
    return 1
L10:
    r20 = <error> :: None
    return r20
L11:
    dec_ref r13
    goto L10

def validate_list_like_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: tuple[object, object]
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7, r8 :: str
    r9 :: object
    r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: None
L0:
    r0 = load_address PyList_Type
    r1 = load_address PyTuple_Type
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[object, object], r2)
    r4 = PyObject_IsInstance(param, r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L9 (error at validate_list_like_param:14) else goto L1 :: bool
L1:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L8 else goto L2 :: bool
L2:
    r7 = 'The `'
    r8 = '` value type must be one of list or tuple. Got '
    r9 = CPy_TYPE(param)
    r10 = PyObject_Str(r9)
    dec_ref r9
    if is_error(r10) goto L9 (error at validate_list_like_param:16) else goto L3
L3:
    r11 = CPyStr_Build(4, r7, param_name, r8, r10)
    dec_ref r10
    if is_error(r11) goto L9 (error at validate_list_like_param:16) else goto L4
L4:
    r12 = builtins :: module
    r13 = 'TypeError'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L10 (error at validate_list_like_param:15) else goto L5
L5:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L10 (error at validate_list_like_param:15) else goto L6
L6:
    dec_ref r11
    CPy_Raise(r17)
    dec_ref r17
    if not 0 goto L9 (error at validate_list_like_param:15) else goto L7 :: bool
L7:
    unreachable
L8:
    return 1
L9:
    r18 = <error> :: None
    return r18
L10:
    dec_ref r11
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.validation.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def encode_c(self, types, args):
    self, types, args :: object
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: None
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: tuple
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: bytes
L0:
    r0 = 'types'
    r1 = validate_list_like_param(types, r0)
    if is_error(r1) goto L9 (error at encode_c:44) else goto L1
L1:
    r2 = 'args'
    r3 = validate_list_like_param(args, r2)
    if is_error(r3) goto L9 (error at encode_c:45) else goto L2
L2:
    r4 = '_registry'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L9 (error at encode_c:47) else goto L3
L3:
    r6 = 'get_tuple_encoder'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L9 (error at encode_c:47) else goto L4
L4:
    r8 = PySequence_Tuple(types)
    if is_error(r8) goto L10 (error at encode_c:47) else goto L5
L5:
    r9 = PyObject_CallObject(r7, r8)
    dec_ref r7
    dec_ref r8
    if is_error(r9) goto L9 (error at encode_c:47) else goto L6
L6:
    r10 = [args]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L9 (error at encode_c:49) else goto L7
L7:
    r13 = cast(bytes, r12)
    if is_error(r13) goto L9 (error at encode_c:49) else goto L8
L8:
    return r13
L9:
    r14 = <error> :: bytes
    return r14
L10:
    dec_ref r7
    goto L9

def decode_c(self, types, data, strict):
    self, types :: object
    data :: union[bytes, object]
    strict :: bool
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: None
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: list
    r9 :: object
    r10 :: str
    r11 :: tuple
    r12 :: object
    r13 :: dict
    r14 :: object
    r15 :: str
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22, r23 :: tuple
L0:
    if is_error(strict) goto L1 else goto L2
L1:
    strict = 1
L2:
    r0 = 'types'
    r1 = validate_list_like_param(types, r0)
    if is_error(r1) goto L15 (error at decode_c:76) else goto L3
L3:
    r2 = 'data'
    r3 = validate_bytes_param(data, r2)
    if is_error(r3) goto L15 (error at decode_c:77) else goto L4
L4:
    r4 = '_registry'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L15 (error at decode_c:79) else goto L5
L5:
    r6 = 'get_tuple_decoder'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L15 (error at decode_c:79) else goto L6
L6:
    r8 = PyList_New(0)
    if is_error(r8) goto L16 (error at decode_c:79) else goto L7
L7:
    r9 = CPyList_Extend(r8, types)
    if is_error(r9) goto L17 (error at decode_c:79) else goto L18
L8:
    r10 = 'strict'
    r11 = PyList_AsTuple(r8)
    dec_ref r8
    if is_error(r11) goto L16 (error at decode_c:79) else goto L9
L9:
    r12 = box(bool, strict)
    r13 = CPyDict_Build(1, r10, r12)
    if is_error(r13) goto L19 (error at decode_c:79) else goto L10
L10:
    r14 = PyObject_Call(r7, r11, r13)
    dec_ref r7
    dec_ref r11
    dec_ref r13
    if is_error(r14) goto L15 (error at decode_c:79) else goto L11
L11:
    r15 = 'stream_class'
    r16 = [self, data]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775810, 0)
    if is_error(r18) goto L20 (error at decode_c:80) else goto L12
L12:
    r19 = [r18]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r14, r20, 1, 0)
    dec_ref r14
    if is_error(r21) goto L21 (error at decode_c:82) else goto L13
L13:
    dec_ref r18
    r22 = cast(tuple, r21)
    if is_error(r22) goto L15 (error at decode_c:82) else goto L14
L14:
    return r22
L15:
    r23 = <error> :: tuple
    return r23
L16:
    dec_ref r7
    goto L15
L17:
    dec_ref r7
    dec_ref r8
    goto L15
L18:
    dec_ref r9
    goto L8
L19:
    dec_ref r7
    dec_ref r11
    goto L15
L20:
    dec_ref r14
    goto L15
L21:
    dec_ref r18
    goto L15

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Iterable', 'Tuple', 'cast')
    r6 = 'typing'
    r7 = faster_eth_abi._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('Decodable', 'TypeStr')
    r10 = 'eth_typing'
    r11 = faster_eth_abi._codec.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L8 (error at <module>:9) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('validate_bytes_param', 'validate_list_like_param')
    r14 = 'faster_eth_abi.utils.validation'
    r15 = faster_eth_abi._codec.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L8 (error at <module>:14) else goto L6
L6:
    faster_eth_abi.utils.validation = r16 :: module
    dec_ref r16
    if 0 goto L7 else goto L7 :: bool
L7:
    return 1
L8:
    r17 = <error> :: None
    return r17

def zpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad:2) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad:2) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad(value, 64)
    if is_error(r0) goto L2 (error at zpad32:6) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def zpad_right(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'ljust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad_right:10) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad_right:10) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32_right(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad_right(value, 64)
    if is_error(r0) goto L2 (error at zpad32_right:14) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def fpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\xff'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at fpad:18) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at fpad:18) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def fpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = fpad(value, 64)
    if is_error(r0) goto L2 (error at fpad32:22) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('get_abi_strategy',)
    r6 = 'faster_eth_abi.tools._strategies'
    r7 = faster_eth_abi.tools.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    faster_eth_abi.tools._strategies = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def new_from_type_str_parse_type_str_decorator_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_type_str_decorator_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: str
    r9 :: dict
    r10 :: str
    r11 :: object
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15, type_str_repr :: str
    r16 :: bool
    r17 :: bit
    r18, r19, r20, r21 :: str
    r22 :: object[3]
    r23 :: object_ptr
    r24 :: object
    r25, r26, r27, r28, r29 :: str
    r30 :: object[3]
    r31 :: object_ptr
    r32 :: object
    r33, r34 :: str
    r35 :: list
    r36, r37, r38, r39, r40 :: ptr
    r41 :: str
    r42 :: union[str, None]
    r43 :: object
    r44 :: bit
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: i32
    r49 :: bit
    r50 :: bool
    r51 :: object
    r52, r53, r54, r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: object[1]
    r60 :: object_ptr
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: str
    r65 :: union[str, None]
    r66 :: str
    r67 :: bool
    r68 :: bit
    r69 :: object
    r70 :: str
    r71 :: union[str, None]
    r72, r73, r74, r75, r76, r77 :: str
    r78 :: object
    r79 :: str
    r80 :: object
    r81 :: object[1]
    r82 :: object_ptr
    r83 :: object
    r84 :: bool
    r85 :: str
    r86, r87 :: object
    r88 :: bit
    r89 :: object
    r90, r91, r92, r93, r94 :: str
    r95 :: object
    r96 :: str
    r97 :: object
    r98 :: object[1]
    r99 :: object_ptr
    r100 :: object
    r101 :: bool
    r102 :: str
    r103, r104 :: object
    r105 :: bit
    r106 :: object
    r107, r108, r109, r110, r111 :: str
    r112 :: object
    r113 :: str
    r114 :: object
    r115 :: object[1]
    r116 :: object_ptr
    r117 :: object
    r118 :: str
    r119 :: object[1]
    r120 :: object_ptr
    r121, r122 :: object
    r123 :: object[3]
    r124 :: object_ptr
    r125, r126 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L68 (error at new_from_type_str:48) else goto L1
L1:
    r1 = r0.__mypyc_env__
    if is_error(r1) goto L69 (error at new_from_type_str:48) else goto L2
L2:
    r2 = faster_eth_abi.from_type_str.globals :: static
    r3 = 'normalize'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L70 (error at new_from_type_str:49) else goto L3
L3:
    r5 = [type_str]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L70 (error at new_from_type_str:49) else goto L4
L4:
    r8 = cast(str, r7)
    if is_error(r8) goto L70 (error at new_from_type_str:49) else goto L5
L5:
    r9 = faster_eth_abi.from_type_str.globals :: static
    r10 = 'parse'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L71 (error at new_from_type_str:50) else goto L6
L6:
    r12 = [r8]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 1, 0)
    dec_ref r11
    if is_error(r14) goto L71 (error at new_from_type_str:50) else goto L7
L7:
    r15 = PyObject_Repr(type_str)
    if is_error(r15) goto L72 (error at new_from_type_str:52) else goto L8
L8:
    type_str_repr = r15
    r16 = CPyStr_Equal(type_str, r8)
    r17 = r16 == 0
    if r17 goto L9 else goto L73 :: bool
L9:
    r18 = ''
    r19 = '{:{}}'
    r20 = ''
    r21 = 'format'
    r22 = [r19, type_str_repr, r20]
    r23 = load_address r22
    r24 = PyObject_VectorcallMethod(r21, r23, 9223372036854775811, 0)
    if is_error(r24) goto L74 (error at new_from_type_str:55) else goto L10
L10:
    dec_ref type_str_repr
    r25 = cast(str, r24)
    if is_error(r25) goto L72 (error at new_from_type_str:55) else goto L11
L11:
    r26 = ' (normalized to '
    r27 = '{!r:{}}'
    r28 = ''
    r29 = 'format'
    r30 = [r27, r8, r28]
    r31 = load_address r30
    r32 = PyObject_VectorcallMethod(r29, r31, 9223372036854775811, 0)
    if is_error(r32) goto L75 (error at new_from_type_str:55) else goto L12
L12:
    dec_ref r8
    r33 = cast(str, r32)
    if is_error(r33) goto L76 (error at new_from_type_str:55) else goto L13
L13:
    r34 = ')'
    r35 = PyList_New(4)
    if is_error(r35) goto L77 (error at new_from_type_str:55) else goto L14
L14:
    r36 = get_element_ptr r35 ob_item :: PyListObject
    r37 = load_mem r36 :: ptr*
    set_mem r37, r25 :: builtins.object*
    inc_ref r26
    r38 = r37 + 8
    set_mem r38, r26 :: builtins.object*
    r39 = r37 + 16
    set_mem r39, r33 :: builtins.object*
    inc_ref r34
    r40 = r37 + 24
    set_mem r40, r34 :: builtins.object*
    r41 = PyUnicode_Join(r18, r35)
    dec_ref r35
    if is_error(r41) goto L78 (error at new_from_type_str:55) else goto L15
L15:
    type_str_repr = r41
L16:
    r42 = r1.expected_base
    if is_error(r42) goto L79 (error at new_from_type_str:58) else goto L17
L17:
    r43 = load_address _Py_NoneStruct
    r44 = r42 != r43
    dec_ref r42
    if r44 goto L18 else goto L42 :: bool
L18:
    r45 = faster_eth_abi.from_type_str.globals :: static
    r46 = 'BasicType'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L79 (error at new_from_type_str:59) else goto L19
L19:
    r48 = PyObject_IsInstance(r14, r47)
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L79 (error at new_from_type_str:59) else goto L20 :: bool
L20:
    r50 = truncate r48: i32 to builtins.bool
    if r50 goto L28 else goto L80 :: bool
L21:
    r51 = CPy_GetName(cls)
    if is_error(r51) goto L81 (error at new_from_type_str:62) else goto L22
L22:
    r52 = cast(str, r51)
    if is_error(r52) goto L81 (error at new_from_type_str:62) else goto L23
L23:
    r53 = 'Cannot create '
    r54 = ' for non-basic type '
    r55 = CPyStr_Build(4, r53, r52, r54, type_str_repr)
    dec_ref r52
    dec_ref type_str_repr
    if is_error(r55) goto L68 (error at new_from_type_str:61) else goto L24
L24:
    r56 = builtins :: module
    r57 = 'ValueError'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L82 (error at new_from_type_str:60) else goto L25
L25:
    r59 = [r55]
    r60 = load_address r59
    r61 = PyObject_Vectorcall(r58, r60, 1, 0)
    dec_ref r58
    if is_error(r61) goto L82 (error at new_from_type_str:60) else goto L26
L26:
    dec_ref r55
    CPy_Raise(r61)
    dec_ref r61
    if not 0 goto L68 (error at new_from_type_str:60) else goto L27 :: bool
L27:
    unreachable
L28:
    r62 = 'base'
    r63 = CPyObject_GetAttr(r14, r62)
    if is_error(r63) goto L79 (error at new_from_type_str:66) else goto L29
L29:
    r64 = cast(str, r63)
    if is_error(r64) goto L79 (error at new_from_type_str:66) else goto L30
L30:
    r65 = r1.expected_base
    if is_error(r65) goto L83 (error at new_from_type_str:66) else goto L31
L31:
    r66 = cast(str, r65)
    if is_error(r66) goto L83 (error at new_from_type_str:66) else goto L32
L32:
    r67 = CPyStr_Equal(r64, r66)
    dec_ref r64
    dec_ref r66
    r68 = r67 == 0
    if r68 goto L84 else goto L42 :: bool
L33:
    r69 = CPy_GetName(cls)
    if is_error(r69) goto L85 (error at new_from_type_str:70) else goto L34
L34:
    r70 = cast(str, r69)
    if is_error(r70) goto L85 (error at new_from_type_str:70) else goto L35
L35:
    r71 = r1.expected_base
    dec_ref r1
    if is_error(r71) goto L86 (error at new_from_type_str:72) else goto L36
L36:
    r72 = cast(str, r71)
    if is_error(r72) goto L86 (error at new_from_type_str:72) else goto L37
L37:
    r73 = 'Cannot create '
    r74 = ' for type '
    r75 = ": expected type with base '"
    r76 = "'"
    r77 = CPyStr_Build(7, r73, r70, r74, type_str_repr, r75, r72, r76)
    dec_ref r70
    dec_ref type_str_repr
    dec_ref r72
    if is_error(r77) goto L68 (error at new_from_type_str:68) else goto L38
L38:
    r78 = builtins :: module
    r79 = 'ValueError'
    r80 = CPyObject_GetAttr(r78, r79)
    if is_error(r80) goto L87 (error at new_from_type_str:67) else goto L39
L39:
    r81 = [r77]
    r82 = load_address r81
    r83 = PyObject_Vectorcall(r80, r82, 1, 0)
    dec_ref r80
    if is_error(r83) goto L87 (error at new_from_type_str:67) else goto L40
L40:
    dec_ref r77
    CPy_Raise(r83)
    dec_ref r83
    if not 0 goto L68 (error at new_from_type_str:67) else goto L41 :: bool
L41:
    unreachable
L42:
    r84 = r1.with_arrlist
    if is_error(r84) goto L79 (error at new_from_type_str:76) else goto L43
L43:
    if r84 goto L53 else goto L44 :: bool
L44:
    r85 = 'arrlist'
    r86 = CPyObject_GetAttr(r14, r85)
    if is_error(r86) goto L79 (error at new_from_type_str:76) else goto L45
L45:
    r87 = load_address _Py_NoneStruct
    r88 = r86 != r87
    dec_ref r86
    if r88 goto L88 else goto L53 :: bool
L46:
    r89 = CPy_GetName(cls)
    if is_error(r89) goto L81 (error at new_from_type_str:80) else goto L47
L47:
    r90 = cast(str, r89)
    if is_error(r90) goto L81 (error at new_from_type_str:80) else goto L48
L48:
    r91 = 'Cannot create '
    r92 = ' for type '
    r93 = ': expected type with no array dimension list'
    r94 = CPyStr_Build(5, r91, r90, r92, type_str_repr, r93)
    dec_ref r90
    dec_ref type_str_repr
    if is_error(r94) goto L68 (error at new_from_type_str:78) else goto L49
L49:
    r95 = builtins :: module
    r96 = 'ValueError'
    r97 = CPyObject_GetAttr(r95, r96)
    if is_error(r97) goto L89 (error at new_from_type_str:77) else goto L50
L50:
    r98 = [r94]
    r99 = load_address r98
    r100 = PyObject_Vectorcall(r97, r99, 1, 0)
    dec_ref r97
    if is_error(r100) goto L89 (error at new_from_type_str:77) else goto L51
L51:
    dec_ref r94
    CPy_Raise(r100)
    dec_ref r100
    if not 0 goto L68 (error at new_from_type_str:77) else goto L52 :: bool
L52:
    unreachable
L53:
    r101 = r1.with_arrlist
    dec_ref r1
    if is_error(r101) goto L90 (error at new_from_type_str:84) else goto L54
L54:
    if r101 goto L55 else goto L91 :: bool
L55:
    r102 = 'arrlist'
    r103 = CPyObject_GetAttr(r14, r102)
    if is_error(r103) goto L90 (error at new_from_type_str:84) else goto L56
L56:
    r104 = load_address _Py_NoneStruct
    r105 = r103 == r104
    dec_ref r103
    if r105 goto L92 else goto L91 :: bool
L57:
    r106 = CPy_GetName(cls)
    if is_error(r106) goto L81 (error at new_from_type_str:88) else goto L58
L58:
    r107 = cast(str, r106)
    if is_error(r107) goto L81 (error at new_from_type_str:88) else goto L59
L59:
    r108 = 'Cannot create '
    r109 = ' for type '
    r110 = ': expected type with array dimension list'
    r111 = CPyStr_Build(5, r108, r107, r109, type_str_repr, r110)
    dec_ref r107
    dec_ref type_str_repr
    if is_error(r111) goto L68 (error at new_from_type_str:86) else goto L60
L60:
    r112 = builtins :: module
    r113 = 'ValueError'
    r114 = CPyObject_GetAttr(r112, r113)
    if is_error(r114) goto L93 (error at new_from_type_str:85) else goto L61
L61:
    r115 = [r111]
    r116 = load_address r115
    r117 = PyObject_Vectorcall(r114, r116, 1, 0)
    dec_ref r114
    if is_error(r117) goto L93 (error at new_from_type_str:85) else goto L62
L62:
    dec_ref r111
    CPy_Raise(r117)
    dec_ref r117
    if not 0 goto L68 (error at new_from_type_str:85) else goto L63 :: bool
L63:
    unreachable
L64:
    r118 = 'validate'
    r119 = [r14]
    r120 = load_address r119
    r121 = PyObject_VectorcallMethod(r118, r120, 9223372036854775809, 0)
    if is_error(r121) goto L94 (error at new_from_type_str:94) else goto L95
L65:
    r122 = r0.old_from_type_str
    dec_ref r0
    if is_error(r122) goto L96 (error at new_from_type_str:96) else goto L66
L66:
    r123 = [cls, r14, registry]
    r124 = load_address r123
    r125 = PyObject_Vectorcall(r122, r124, 3, 0)
    dec_ref r122
    if is_error(r125) goto L96 (error at new_from_type_str:96) else goto L67
L67:
    dec_ref r14
    return r125
L68:
    r126 = <error> :: object
    return r126
L69:
    dec_ref r0
    goto L68
L70:
    dec_ref r0
    dec_ref r1
    goto L68
L71:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    goto L68
L72:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    goto L68
L73:
    dec_ref r8
    goto L16
L74:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    dec_ref type_str_repr
    goto L68
L75:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    dec_ref r25
    goto L68
L76:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref r25
    goto L68
L77:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref r25
    dec_ref r33
    goto L68
L78:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L68
L79:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref type_str_repr
    goto L68
L80:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L21
L81:
    dec_ref type_str_repr
    goto L68
L82:
    dec_ref r55
    goto L68
L83:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref type_str_repr
    dec_ref r64
    goto L68
L84:
    dec_ref r0
    dec_ref r14
    goto L33
L85:
    dec_ref r1
    dec_ref type_str_repr
    goto L68
L86:
    dec_ref type_str_repr
    dec_ref r70
    goto L68
L87:
    dec_ref r77
    goto L68
L88:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L46
L89:
    dec_ref r94
    goto L68
L90:
    dec_ref r0
    dec_ref r14
    dec_ref type_str_repr
    goto L68
L91:
    dec_ref type_str_repr
    goto L64
L92:
    dec_ref r0
    dec_ref r14
    goto L57
L93:
    dec_ref r111
    goto L68
L94:
    dec_ref r0
    dec_ref r14
    goto L68
L95:
    dec_ref r121
    goto L65
L96:
    dec_ref r14
    goto L68

def decorator_parse_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def decorator_parse_type_str_obj.__call__(__mypyc_self__, old_from_type_str):
    __mypyc_self__ :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    r5 :: bool
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L14 (error at decorator:46) else goto L1
L1:
    r1 = decorator_parse_type_str_env()
    if is_error(r1) goto L15 (error at decorator:46) else goto L2
L2:
    r1.__mypyc_env__ = r0; r2 = is_error
    if not r2 goto L16 (error at decorator:46) else goto L3 :: bool
L3:
    inc_ref old_from_type_str
    r1.old_from_type_str = old_from_type_str; r3 = is_error
    if not r3 goto L16 (error at decorator:46) else goto L4 :: bool
L4:
    r4 = new_from_type_str_parse_type_str_decorator_obj()
    if is_error(r4) goto L16 (error at decorator:48) else goto L5
L5:
    inc_ref r1
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L17 (error at decorator:48) else goto L6 :: bool
L6:
    r6 = r1.old_from_type_str
    dec_ref r1
    if is_error(r6) goto L18 (error at decorator:47) else goto L7
L7:
    r7 = functools :: module
    r8 = 'wraps'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L19 (error at decorator:47) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L19 (error at decorator:47) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L18 (error at decorator:48) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = faster_eth_abi.from_type_str.globals :: static
    r17 = 'new_from_type_str'
    r18 = PyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L20 (error at decorator:48) else goto L11 :: bool
L11:
    r20 = builtins :: module
    r21 = 'classmethod'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L20 (error at decorator:98) else goto L12
L12:
    r23 = [r15]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L20 (error at decorator:98) else goto L13
L13:
    dec_ref r15
    return r25
L14:
    r26 = <error> :: object
    return r26
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r1
    goto L14
L17:
    dec_ref r1
    dec_ref r4
    goto L14
L18:
    dec_ref r4
    goto L14
L19:
    dec_ref r4
    dec_ref r6
    goto L14
L20:
    dec_ref r15
    goto L14

def parse_type_str(expected_base, with_arrlist):
    expected_base :: union[str, None]
    with_arrlist :: bool
    r0 :: object
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    r5 :: bool
    decorator, r6 :: object
L0:
    if is_error(expected_base) goto L1 else goto L11
L1:
    r0 = box(None, 1)
    inc_ref r0
    expected_base = r0
L2:
    if is_error(with_arrlist) goto L3 else goto L4
L3:
    with_arrlist = 0
L4:
    r1 = parse_type_str_env()
    if is_error(r1) goto L12 (error at parse_type_str:35) else goto L5
L5:
    r1.expected_base = expected_base; r2 = is_error
    if not r2 goto L13 (error at parse_type_str:35) else goto L6 :: bool
L6:
    r1.with_arrlist = with_arrlist; r3 = is_error
    if not r3 goto L13 (error at parse_type_str:35) else goto L7 :: bool
L7:
    r4 = decorator_parse_type_str_obj()
    if is_error(r4) goto L13 (error at parse_type_str:46) else goto L8
L8:
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L14 (error at parse_type_str:46) else goto L9 :: bool
L9:
    decorator = r4
    return decorator
L10:
    r6 = <error> :: object
    return r6
L11:
    inc_ref expected_base
    goto L2
L12:
    dec_ref expected_base
    goto L10
L13:
    dec_ref r1
    goto L10
L14:
    dec_ref r4
    goto L10

def new_from_type_str_parse_tuple_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_tuple_type_str_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: dict
    r9 :: str
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: i32
    r18 :: bit
    r19 :: bool
    r20, type_str_repr :: str
    r21 :: bool
    r22 :: bit
    r23, r24, r25, r26 :: str
    r27 :: object
    r28, r29, r30, r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35 :: object[1]
    r36 :: object_ptr
    r37 :: object
    r38 :: str
    r39 :: object[1]
    r40 :: object_ptr
    r41, r42 :: object
    r43 :: object[3]
    r44 :: object_ptr
    r45, r46 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L25 (error at new_from_type_str:113) else goto L1
L1:
    r1 = faster_eth_abi.from_type_str.globals :: static
    r2 = 'normalize'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L26 (error at new_from_type_str:114) else goto L2
L2:
    r4 = [type_str]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L26 (error at new_from_type_str:114) else goto L3
L3:
    r7 = cast(str, r6)
    if is_error(r7) goto L26 (error at new_from_type_str:114) else goto L4
L4:
    r8 = faster_eth_abi.from_type_str.globals :: static
    r9 = 'parse'
    r10 = CPyDict_GetItem(r8, r9)
    if is_error(r10) goto L27 (error at new_from_type_str:115) else goto L5
L5:
    r11 = [r7]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L27 (error at new_from_type_str:115) else goto L6
L6:
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'TupleType'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L28 (error at new_from_type_str:117) else goto L7
L7:
    r17 = PyObject_IsInstance(r13, r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L28 (error at new_from_type_str:117) else goto L8 :: bool
L8:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L29 else goto L30 :: bool
L9:
    r20 = PyObject_Repr(type_str)
    if is_error(r20) goto L31 (error at new_from_type_str:118) else goto L10
L10:
    type_str_repr = r20
    r21 = CPyStr_Equal(type_str, r7)
    r22 = r21 == 0
    if r22 goto L11 else goto L32 :: bool
L11:
    r23 = PyObject_Repr(r7)
    dec_ref r7
    if is_error(r23) goto L33 (error at new_from_type_str:122) else goto L12
L12:
    r24 = ' (normalized to '
    r25 = ')'
    r26 = CPyStr_Build(4, type_str_repr, r24, r23, r25)
    dec_ref type_str_repr
    dec_ref r23
    if is_error(r26) goto L25 (error at new_from_type_str:120) else goto L13
L13:
    type_str_repr = r26
L14:
    r27 = CPy_GetName(cls)
    if is_error(r27) goto L33 (error at new_from_type_str:126) else goto L15
L15:
    r28 = cast(str, r27)
    if is_error(r28) goto L33 (error at new_from_type_str:126) else goto L16
L16:
    r29 = 'Cannot create '
    r30 = ' for non-tuple type '
    r31 = CPyStr_Build(4, r29, r28, r30, type_str_repr)
    dec_ref r28
    dec_ref type_str_repr
    if is_error(r31) goto L25 (error at new_from_type_str:125) else goto L17
L17:
    r32 = builtins :: module
    r33 = 'ValueError'
    r34 = CPyObject_GetAttr(r32, r33)
    if is_error(r34) goto L34 (error at new_from_type_str:124) else goto L18
L18:
    r35 = [r31]
    r36 = load_address r35
    r37 = PyObject_Vectorcall(r34, r36, 1, 0)
    dec_ref r34
    if is_error(r37) goto L34 (error at new_from_type_str:124) else goto L19
L19:
    dec_ref r31
    CPy_Raise(r37)
    dec_ref r37
    if not 0 goto L25 (error at new_from_type_str:124) else goto L20 :: bool
L20:
    unreachable
L21:
    r38 = 'validate'
    r39 = [r13]
    r40 = load_address r39
    r41 = PyObject_VectorcallMethod(r38, r40, 9223372036854775809, 0)
    if is_error(r41) goto L35 (error at new_from_type_str:131) else goto L36
L22:
    r42 = r0.old_from_type_str
    dec_ref r0
    if is_error(r42) goto L37 (error at new_from_type_str:133) else goto L23
L23:
    r43 = [cls, r13, registry]
    r44 = load_address r43
    r45 = PyObject_Vectorcall(r42, r44, 3, 0)
    dec_ref r42
    if is_error(r45) goto L37 (error at new_from_type_str:133) else goto L24
L24:
    dec_ref r13
    return r45
L25:
    r46 = <error> :: object
    return r46
L26:
    dec_ref r0
    goto L25
L27:
    dec_ref r0
    dec_ref r7
    goto L25
L28:
    dec_ref r0
    dec_ref r7
    dec_ref r13
    goto L25
L29:
    dec_ref r7
    goto L21
L30:
    dec_ref r0
    dec_ref r13
    goto L9
L31:
    dec_ref r7
    goto L25
L32:
    dec_ref r7
    goto L14
L33:
    dec_ref type_str_repr
    goto L25
L34:
    dec_ref r31
    goto L25
L35:
    dec_ref r0
    dec_ref r13
    goto L25
L36:
    dec_ref r41
    goto L22
L37:
    dec_ref r13
    goto L25

def parse_tuple_type_str(old_from_type_str):
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: bool
    r2 :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    r3 :: bool
    r4, r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23, r24 :: object
L0:
    r0 = parse_tuple_type_str_env()
    if is_error(r0) goto L12 (error at parse_tuple_type_str:103) else goto L1
L1:
    inc_ref old_from_type_str
    r0.old_from_type_str = old_from_type_str; r1 = is_error
    if not r1 goto L13 (error at parse_tuple_type_str:103) else goto L2 :: bool
L2:
    r2 = new_from_type_str_parse_tuple_type_str_obj()
    if is_error(r2) goto L13 (error at parse_tuple_type_str:113) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L14 (error at parse_tuple_type_str:113) else goto L4 :: bool
L4:
    r4 = r0.old_from_type_str
    dec_ref r0
    if is_error(r4) goto L15 (error at parse_tuple_type_str:112) else goto L5
L5:
    r5 = functools :: module
    r6 = 'wraps'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L16 (error at parse_tuple_type_str:112) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L16 (error at parse_tuple_type_str:112) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L15 (error at parse_tuple_type_str:113) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'new_from_type_str'
    r16 = PyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L17 (error at parse_tuple_type_str:113) else goto L9 :: bool
L9:
    r18 = builtins :: module
    r19 = 'classmethod'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L17 (error at parse_tuple_type_str:135) else goto L10
L10:
    r21 = [r13]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L17 (error at parse_tuple_type_str:135) else goto L11
L11:
    dec_ref r13
    return r23
L12:
    r24 = <error> :: object
    return r24
L13:
    dec_ref r0
    goto L12
L14:
    dec_ref r0
    dec_ref r2
    goto L12
L15:
    dec_ref r2
    goto L12
L16:
    dec_ref r2
    dec_ref r4
    goto L12
L17:
    dec_ref r13
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: object
    r36 :: object[2]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: i32
    r43 :: bit
    r44 :: dict
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: list
    r55, r56, r57, r58 :: ptr
    r59 :: dict
    r60 :: str
    r61 :: object
    r62 :: tuple[list, object]
    r63, r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: i32
    r68 :: bit
    r69 :: object
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: list
    r82, r83, r84 :: ptr
    r85 :: dict
    r86 :: str
    r87 :: object
    r88 :: tuple[object, list, object]
    r89, r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address functools :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('functools', 'functools', 'functools'),)
    r11 = faster_eth_abi.from_type_str.globals :: static
    r12 = 'faster_eth_abi/from_type_str.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('TYPE_CHECKING', 'Any', 'Callable', 'Optional', 'Type', 'TypeVar')
    r16 = 'typing'
    r17 = faster_eth_abi.from_type_str.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('TypeStr',)
    r20 = 'eth_typing'
    r21 = faster_eth_abi.from_type_str.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L30 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('ABIType', 'BasicType', 'TupleType', 'normalize', 'parse')
    r24 = 'faster_eth_abi.grammar'
    r25 = faster_eth_abi.from_type_str.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L30 (error at <module>:15) else goto L7
L7:
    faster_eth_abi.grammar = r26 :: module
    dec_ref r26
    if 0 goto L8 else goto L8 :: bool
L8:
    r27 = 'TType'
    r28 = faster_eth_abi.from_type_str.globals :: static
    r29 = 'Type'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L30 (error at <module>:29) else goto L9
L9:
    r31 = 'BaseCoder'
    r32 = PyObject_GetItem(r30, r31)
    dec_ref r30
    if is_error(r32) goto L30 (error at <module>:29) else goto L10
L10:
    r33 = faster_eth_abi.from_type_str.globals :: static
    r34 = 'TypeVar'
    r35 = CPyDict_GetItem(r33, r34)
    if is_error(r35) goto L31 (error at <module>:29) else goto L11
L11:
    r36 = [r27, r32]
    r37 = load_address r36
    r38 = ('bound',)
    r39 = PyObject_Vectorcall(r35, r37, 1, r38)
    dec_ref r35
    if is_error(r39) goto L31 (error at <module>:29) else goto L12
L12:
    dec_ref r32
    r40 = faster_eth_abi.from_type_str.globals :: static
    r41 = 'TType'
    r42 = CPyDict_SetItem(r40, r41, r39)
    dec_ref r39
    r43 = r42 >= 0 :: signed
    if not r43 goto L30 (error at <module>:29) else goto L13 :: bool
L13:
    r44 = faster_eth_abi.from_type_str.globals :: static
    r45 = 'Callable'
    r46 = CPyDict_GetItem(r44, r45)
    if is_error(r46) goto L30 (error at <module>:30) else goto L14
L14:
    r47 = 'BaseCoder'
    r48 = faster_eth_abi.from_type_str.globals :: static
    r49 = 'ABIType'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L32 (error at <module>:30) else goto L15
L15:
    r51 = faster_eth_abi.from_type_str.globals :: static
    r52 = 'Any'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L33 (error at <module>:30) else goto L16
L16:
    r54 = PyList_New(3)
    if is_error(r54) goto L34 (error at <module>:30) else goto L17
L17:
    r55 = get_element_ptr r54 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    inc_ref r47
    set_mem r56, r47 :: builtins.object*
    r57 = r56 + 8
    set_mem r57, r50 :: builtins.object*
    r58 = r56 + 16
    set_mem r58, r53 :: builtins.object*
    r59 = faster_eth_abi.from_type_str.globals :: static
    r60 = 'TType'
    r61 = CPyDict_GetItem(r59, r60)
    if is_error(r61) goto L35 (error at <module>:30) else goto L18
L18:
    r62 = (r54, r61)
    r63 = box(tuple[list, object], r62)
    r64 = PyObject_GetItem(r46, r63)
    dec_ref r46
    dec_ref r63
    if is_error(r64) goto L30 (error at <module>:30) else goto L19
L19:
    r65 = faster_eth_abi.from_type_str.globals :: static
    r66 = 'OldFromTypeStr'
    r67 = CPyDict_SetItem(r65, r66, r64)
    dec_ref r64
    r68 = r67 >= 0 :: signed
    if not r68 goto L30 (error at <module>:30) else goto L20 :: bool
L20:
    if 0 goto L21 else goto L29 :: bool
L21:
    r69 = builtins :: module
    r70 = 'classmethod'
    r71 = CPyObject_GetAttr(r69, r70)
    if is_error(r71) goto L30 (error at <module>:32) else goto L22
L22:
    r72 = faster_eth_abi.from_type_str.globals :: static
    r73 = 'TType'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L36 (error at <module>:32) else goto L23
L23:
    r75 = faster_eth_abi.from_type_str.globals :: static
    r76 = 'TypeStr'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L37 (error at <module>:32) else goto L24
L24:
    r78 = faster_eth_abi.from_type_str.globals :: static
    r79 = 'Any'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L38 (error at <module>:32) else goto L25
L25:
    r81 = PyList_New(2)
    if is_error(r81) goto L39 (error at <module>:32) else goto L26
L26:
    r82 = get_element_ptr r81 ob_item :: PyListObject
    r83 = load_mem r82 :: ptr*
    set_mem r83, r77 :: builtins.object*
    r84 = r83 + 8
    set_mem r84, r80 :: builtins.object*
    r85 = faster_eth_abi.from_type_str.globals :: static
    r86 = 'TType'
    r87 = CPyDict_GetItem(r85, r86)
    if is_error(r87) goto L40 (error at <module>:32) else goto L27
L27:
    r88 = (r74, r81, r87)
    r89 = box(tuple[object, list, object], r88)
    r90 = PyObject_GetItem(r71, r89)
    dec_ref r71
    dec_ref r89
    if is_error(r90) goto L30 (error at <module>:32) else goto L28
L28:
    r91 = faster_eth_abi.from_type_str.globals :: static
    r92 = 'NewFromTypeStr'
    r93 = CPyDict_SetItem(r91, r92, r90)
    dec_ref r90
    r94 = r93 >= 0 :: signed
    if not r94 goto L30 (error at <module>:32) else goto L29 :: bool
L29:
    return 1
L30:
    r95 = <error> :: None
    return r95
L31:
    dec_ref r32
    goto L30
L32:
    dec_ref r46
    goto L30
L33:
    dec_ref r46
    dec_ref r50
    goto L30
L34:
    dec_ref r46
    dec_ref r50
    dec_ref r53
    goto L30
L35:
    dec_ref r46
    dec_ref r54
    goto L30
L36:
    dec_ref r71
    goto L30
L37:
    dec_ref r71
    dec_ref r74
    goto L30
L38:
    dec_ref r71
    dec_ref r74
    dec_ref r77
    goto L30
L39:
    dec_ref r71
    dec_ref r74
    dec_ref r77
    dec_ref r80
    goto L30
L40:
    dec_ref r71
    dec_ref r74
    dec_ref r81
    goto L30

def StrategyRegistry.__init__(self):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
    r8 :: None
L0:
    r0 = 'strategy registry'
    r1 = faster_eth_abi.tools._strategies.globals :: static
    r2 = 'PredicateMapping'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L4 (error at __init__:43) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __init__:43) else goto L2
L2:
    self._strategies = r6; r7 = is_error
    if not r7 goto L4 (error at __init__:43) else goto L3 :: bool
L3:
    return 1
L4:
    r8 = <error> :: None
    return r8

def StrategyRegistry.register_strategy(self, lookup, registration, label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup :: union[str, object]
    registration :: object
    label :: union[str, None]
    r0, r1 :: object
    r2 :: str
    r3 :: object[5]
    r4 :: object_ptr
    r5, r6 :: object
    r7 :: None
L0:
    if is_error(label) goto L1 else goto L6
L1:
    r0 = box(None, 1)
    inc_ref r0
    label = r0
L2:
    r1 = self._strategies
    if is_error(r1) goto L7 (error at register_strategy:51) else goto L3
L3:
    r2 = '_register'
    r3 = [self, r1, lookup, registration, label]
    r4 = load_address r3
    r5 = ('label',)
    r6 = PyObject_VectorcallMethod(r2, r4, 9223372036854775812, r5)
    if is_error(r6) goto L8 (error at register_strategy:51) else goto L9
L4:
    dec_ref r1
    dec_ref label
    return 1
L5:
    r7 = <error> :: None
    return r7
L6:
    inc_ref label
    goto L2
L7:
    dec_ref label
    goto L5
L8:
    dec_ref label
    dec_ref r1
    goto L5
L9:
    dec_ref r6
    goto L4

def StrategyRegistry.unregister_strategy(self, lookup_or_label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup_or_label :: union[str, object]
    r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: None
L0:
    r0 = self._strategies
    if is_error(r0) goto L3 (error at unregister_strategy:54) else goto L1
L1:
    r1 = '_unregister'
    r2 = [self, r0, lookup_or_label]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L4 (error at unregister_strategy:54) else goto L5
L2:
    dec_ref r0
    return 1
L3:
    r5 = <error> :: None
    return r5
L4:
    dec_ref r0
    goto L3
L5:
    dec_ref r4
    goto L2

def StrategyRegistry.get_strategy(self, type_str):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    type_str :: str
    r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: object[2]
    r27 :: object_ptr
    r28, r29 :: object
L0:
    r0 = self._strategies
    if is_error(r0) goto L14 (error at get_strategy:66) else goto L1
L1:
    r1 = '_get_registration'
    r2 = [self, r0, type_str]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L15 (error at get_strategy:66) else goto L2
L2:
    dec_ref r0
    r5 = faster_eth_abi.tools._strategies.globals :: static
    r6 = 'st'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L16 (error at get_strategy:68) else goto L3
L3:
    r8 = 'SearchStrategy'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L16 (error at get_strategy:68) else goto L4
L4:
    r10 = PyObject_IsInstance(r4, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L16 (error at get_strategy:68) else goto L5 :: bool
L5:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L6 else goto L7 :: bool
L6:
    return r4
L7:
    r13 = faster_eth_abi.tools._strategies.globals :: static
    r14 = 'normalize'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L16 (error at get_strategy:74) else goto L8
L8:
    r16 = [type_str]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L16 (error at get_strategy:74) else goto L9
L9:
    r19 = cast(str, r18)
    if is_error(r19) goto L16 (error at get_strategy:74) else goto L10
L10:
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = 'parse'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L17 (error at get_strategy:75) else goto L11
L11:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L17 (error at get_strategy:75) else goto L12
L12:
    dec_ref r19
    r26 = [r25, self]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r4, r27, 2, 0)
    dec_ref r4
    if is_error(r28) goto L18 (error at get_strategy:76) else goto L13
L13:
    dec_ref r25
    return r28
L14:
    r29 = <error> :: object
    return r29
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r4
    goto L14
L17:
    dec_ref r4
    dec_ref r19
    goto L14
L18:
    dec_ref r25
    goto L14

def get_uint_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8 :: object
    r9 :: str
    r10 :: object
    r11 :: object[3]
    r12 :: object_ptr
    r13, r14, r15 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L6 (error at get_uint_strategy:84) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L7 (error at get_uint_strategy:86) else goto L2
L2:
    r5 = object 2
    r6 = CPyNumber_Power(r5, r1)
    dec_ref r1
    if is_error(r6) goto L8 (error at get_uint_strategy:88) else goto L3
L3:
    r7 = object 1
    r8 = PyNumber_Subtract(r6, r7)
    dec_ref r6
    if is_error(r8) goto L8 (error at get_uint_strategy:88) else goto L4
L4:
    r9 = 'integers'
    r10 = object 0
    r11 = [r4, r10, r8]
    r12 = load_address r11
    r13 = ('min_value', 'max_value')
    r14 = PyObject_VectorcallMethod(r9, r12, 9223372036854775809, r13)
    if is_error(r14) goto L9 (error at get_uint_strategy:86) else goto L5
L5:
    dec_ref r4
    dec_ref r8
    return r14
L6:
    r15 = <error> :: object
    return r15
L7:
    dec_ref r1
    goto L6
L8:
    dec_ref r4
    goto L6
L9:
    dec_ref r4
    dec_ref r8
    goto L6

def get_int_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L10 (error at get_int_strategy:95) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L11 (error at get_int_strategy:97) else goto L2
L2:
    r5 = object 1
    r6 = PyNumber_Subtract(r1, r5)
    if is_error(r6) goto L12 (error at get_int_strategy:98) else goto L3
L3:
    r7 = object 2
    r8 = CPyNumber_Power(r7, r6)
    dec_ref r6
    if is_error(r8) goto L12 (error at get_int_strategy:98) else goto L4
L4:
    r9 = PyNumber_Negative(r8)
    dec_ref r8
    if is_error(r9) goto L12 (error at get_int_strategy:98) else goto L5
L5:
    r10 = object 1
    r11 = PyNumber_Subtract(r1, r10)
    dec_ref r1
    if is_error(r11) goto L13 (error at get_int_strategy:99) else goto L6
L6:
    r12 = object 2
    r13 = CPyNumber_Power(r12, r11)
    dec_ref r11
    if is_error(r13) goto L13 (error at get_int_strategy:99) else goto L7
L7:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L13 (error at get_int_strategy:99) else goto L8
L8:
    r16 = 'integers'
    r17 = [r4, r9, r15]
    r18 = load_address r17
    r19 = ('min_value', 'max_value')
    r20 = PyObject_VectorcallMethod(r16, r18, 9223372036854775809, r19)
    if is_error(r20) goto L14 (error at get_int_strategy:97) else goto L9
L9:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    return r20
L10:
    r21 = <error> :: object
    return r21
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r4
    goto L10
L13:
    dec_ref r4
    dec_ref r9
    goto L10
L14:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    goto L10

def get_ufixed_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1, r2, r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: str
    r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17, r18 :: object
    r19 :: object[4]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: int
    r24 :: object
    r25 :: str
    r26 :: object[2]
    r27 :: object_ptr
    r28, r29 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L19 (error at get_ufixed_strategy:110) else goto L1
L1:
    r2 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r2) goto L19 (error at get_ufixed_strategy:110) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L20 else goto L5
L3:
    r4 = raise ValueError('not enough values to unpack')
    if not r4 goto L19 (error at get_ufixed_strategy:110) else goto L4 :: bool
L4:
    unreachable
L5:
    r5 = PyIter_Next(r2)
    if is_error(r5) goto L21 else goto L8
L6:
    r6 = raise ValueError('not enough values to unpack')
    if not r6 goto L19 (error at get_ufixed_strategy:110) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = PyIter_Next(r2)
    dec_ref r2
    if is_error(r7) goto L11 else goto L22
L9:
    r8 = raise ValueError('too many values to unpack')
    if not r8 goto L19 (error at get_ufixed_strategy:110) else goto L10 :: bool
L10:
    unreachable
L11:
    r9 = faster_eth_abi.tools._strategies.globals :: static
    r10 = 'st'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L23 (error at get_ufixed_strategy:112) else goto L12
L12:
    r12 = object 2
    r13 = CPyNumber_Power(r12, r3)
    dec_ref r3
    if is_error(r13) goto L24 (error at get_ufixed_strategy:114) else goto L13
L13:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L24 (error at get_ufixed_strategy:114) else goto L14
L14:
    r16 = 'decimals'
    r17 = object 0
    r18 = object 0
    r19 = [r11, r17, r15, r18]
    r20 = load_address r19
    r21 = ('min_value', 'max_value', 'places')
    r22 = PyObject_VectorcallMethod(r16, r20, 9223372036854775809, r21)
    if is_error(r22) goto L25 (error at get_ufixed_strategy:112) else goto L15
L15:
    dec_ref r11
    dec_ref r15
    r23 = unbox(int, r5)
    dec_ref r5
    if is_error(r23) goto L26 (error at get_ufixed_strategy:116) else goto L16
L16:
    r24 = scale_places(r23)
    dec_ref r23 :: int
    if is_error(r24) goto L26 (error at get_ufixed_strategy:116) else goto L17
L17:
    r25 = 'map'
    r26 = [r22, r24]
    r27 = load_address r26
    r28 = PyObject_VectorcallMethod(r25, r27, 9223372036854775810, 0)
    if is_error(r28) goto L27 (error at get_ufixed_strategy:112) else goto L18
L18:
    dec_ref r22
    dec_ref r24
    return r28
L19:
    r29 = <error> :: object
    return r29
L20:
    dec_ref r2
    goto L3
L21:
    dec_ref r2
    dec_ref r3
    goto L6
L22:
    dec_ref r3
    dec_ref r5
    dec_ref r7
    goto L9
L23:
    dec_ref r3
    dec_ref r5
    goto L19
L24:
    dec_ref r5
    dec_ref r11
    goto L19
L25:
    dec_ref r5
    dec_ref r11
    dec_ref r15
    goto L19
L26:
    dec_ref r22
    goto L19
L27:
    dec_ref r22
    dec_ref r24
    goto L19

def get_fixed_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1, r2, r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: str
    r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[4]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: int
    r30 :: object
    r31 :: str
    r32 :: object[2]
    r33 :: object_ptr
    r34, r35 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L23 (error at get_fixed_strategy:122) else goto L1
L1:
    r2 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r2) goto L23 (error at get_fixed_strategy:122) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L24 else goto L5
L3:
    r4 = raise ValueError('not enough values to unpack')
    if not r4 goto L23 (error at get_fixed_strategy:122) else goto L4 :: bool
L4:
    unreachable
L5:
    r5 = PyIter_Next(r2)
    if is_error(r5) goto L25 else goto L8
L6:
    r6 = raise ValueError('not enough values to unpack')
    if not r6 goto L23 (error at get_fixed_strategy:122) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = PyIter_Next(r2)
    dec_ref r2
    if is_error(r7) goto L11 else goto L26
L9:
    r8 = raise ValueError('too many values to unpack')
    if not r8 goto L23 (error at get_fixed_strategy:122) else goto L10 :: bool
L10:
    unreachable
L11:
    r9 = faster_eth_abi.tools._strategies.globals :: static
    r10 = 'st'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L27 (error at get_fixed_strategy:124) else goto L12
L12:
    r12 = object 1
    r13 = PyNumber_Subtract(r3, r12)
    if is_error(r13) goto L28 (error at get_fixed_strategy:125) else goto L13
L13:
    r14 = object 2
    r15 = CPyNumber_Power(r14, r13)
    dec_ref r13
    if is_error(r15) goto L28 (error at get_fixed_strategy:125) else goto L14
L14:
    r16 = PyNumber_Negative(r15)
    dec_ref r15
    if is_error(r16) goto L28 (error at get_fixed_strategy:125) else goto L15
L15:
    r17 = object 1
    r18 = PyNumber_Subtract(r3, r17)
    dec_ref r3
    if is_error(r18) goto L29 (error at get_fixed_strategy:126) else goto L16
L16:
    r19 = object 2
    r20 = CPyNumber_Power(r19, r18)
    dec_ref r18
    if is_error(r20) goto L29 (error at get_fixed_strategy:126) else goto L17
L17:
    r21 = object 1
    r22 = PyNumber_Subtract(r20, r21)
    dec_ref r20
    if is_error(r22) goto L29 (error at get_fixed_strategy:126) else goto L18
L18:
    r23 = 'decimals'
    r24 = object 0
    r25 = [r11, r16, r22, r24]
    r26 = load_address r25
    r27 = ('min_value', 'max_value', 'places')
    r28 = PyObject_VectorcallMethod(r23, r26, 9223372036854775809, r27)
    if is_error(r28) goto L30 (error at get_fixed_strategy:124) else goto L19
L19:
    dec_ref r11
    dec_ref r16
    dec_ref r22
    r29 = unbox(int, r5)
    dec_ref r5
    if is_error(r29) goto L31 (error at get_fixed_strategy:128) else goto L20
L20:
    r30 = scale_places(r29)
    dec_ref r29 :: int
    if is_error(r30) goto L31 (error at get_fixed_strategy:128) else goto L21
L21:
    r31 = 'map'
    r32 = [r28, r30]
    r33 = load_address r32
    r34 = PyObject_VectorcallMethod(r31, r33, 9223372036854775810, 0)
    if is_error(r34) goto L32 (error at get_fixed_strategy:124) else goto L22
L22:
    dec_ref r28
    dec_ref r30
    return r34
L23:
    r35 = <error> :: object
    return r35
L24:
    dec_ref r2
    goto L3
L25:
    dec_ref r2
    dec_ref r3
    goto L6
L26:
    dec_ref r3
    dec_ref r5
    dec_ref r7
    goto L9
L27:
    dec_ref r3
    dec_ref r5
    goto L23
L28:
    dec_ref r3
    dec_ref r5
    dec_ref r11
    goto L23
L29:
    dec_ref r5
    dec_ref r11
    dec_ref r16
    goto L23
L30:
    dec_ref r5
    dec_ref r11
    dec_ref r16
    dec_ref r22
    goto L23
L31:
    dec_ref r28
    goto L23
L32:
    dec_ref r28
    dec_ref r30
    goto L23

def get_bytes_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object[3]
    r7 :: object_ptr
    r8, r9, r10 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L4 (error at get_bytes_strategy:134) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L5 (error at get_bytes_strategy:136) else goto L2
L2:
    r5 = 'binary'
    r6 = [r4, r1, r1]
    r7 = load_address r6
    r8 = ('min_size', 'max_size')
    r9 = PyObject_VectorcallMethod(r5, r7, 9223372036854775809, r8)
    if is_error(r9) goto L6 (error at get_bytes_strategy:136) else goto L3
L3:
    dec_ref r4
    dec_ref r1
    return r9
L4:
    r10 = <error> :: object
    return r10
L5:
    dec_ref r1
    goto L4
L6:
    dec_ref r1
    dec_ref r4
    goto L4

def get_array_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9, r10, r11 :: object
    r12 :: int
    r13 :: bit
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object[2]
    r19 :: object_ptr
    r20, r21, r22 :: object
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object[4]
    r28 :: object_ptr
    r29, r30, r31 :: object
L0:
    r0 = 'item_type'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L15 (error at get_array_strategy:149) else goto L1
L1:
    r2 = 'to_type_str'
    r3 = [r1]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775809, 0)
    if is_error(r5) goto L16 (error at get_array_strategy:150) else goto L2
L2:
    dec_ref r1
    r6 = cast(str, r5)
    if is_error(r6) goto L15 (error at get_array_strategy:150) else goto L3
L3:
    r7 = registry.get_strategy(r6)
    dec_ref r6
    if is_error(r7) goto L15 (error at get_array_strategy:151) else goto L4
L4:
    r8 = 'arrlist'
    r9 = CPyObject_GetAttr(abi_type, r8)
    if is_error(r9) goto L17 (error at get_array_strategy:153) else goto L5
L5:
    r10 = object -1
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L17 (error at get_array_strategy:153) else goto L6
L6:
    r12 = CPyObject_Size(r11)
    if is_error(r12) goto L18 (error at get_array_strategy:154) else goto L7
L7:
    r13 = r12 == 0
    dec_ref r12 :: int
    if r13 goto L19 else goto L11 :: bool
L8:
    r14 = faster_eth_abi.tools._strategies.globals :: static
    r15 = 'st'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L17 (error at get_array_strategy:156) else goto L9
L9:
    r17 = 'lists'
    r18 = [r16, r7]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775810, 0)
    if is_error(r20) goto L20 (error at get_array_strategy:156) else goto L10
L10:
    dec_ref r16
    dec_ref r7
    return r20
L11:
    r21 = object 0
    r22 = PyObject_GetItem(r11, r21)
    dec_ref r11
    if is_error(r22) goto L17 (error at get_array_strategy:159) else goto L12
L12:
    r23 = faster_eth_abi.tools._strategies.globals :: static
    r24 = 'st'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L21 (error at get_array_strategy:160) else goto L13
L13:
    r26 = 'lists'
    r27 = [r25, r7, r22, r22]
    r28 = load_address r27
    r29 = ('min_size', 'max_size')
    r30 = PyObject_VectorcallMethod(r26, r28, 9223372036854775810, r29)
    if is_error(r30) goto L22 (error at get_array_strategy:160) else goto L14
L14:
    dec_ref r25
    dec_ref r7
    dec_ref r22
    return r30
L15:
    r31 = <error> :: object
    return r31
L16:
    dec_ref r1
    goto L15
L17:
    dec_ref r7
    goto L15
L18:
    dec_ref r7
    dec_ref r11
    goto L15
L19:
    dec_ref r11
    goto L8
L20:
    dec_ref r7
    dec_ref r16
    goto L15
L21:
    dec_ref r7
    dec_ref r22
    goto L15
L22:
    dec_ref r7
    dec_ref r22
    dec_ref r25
    goto L15

def get_tuple_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: tuple
    r3 :: ptr
    r4 :: native_int
    r5 :: list
    r6 :: ptr
    r7, r8 :: native_int
    r9 :: bit
    r10 :: object
    r11 :: str
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: native_int
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: tuple
    r24, r25 :: object
L0:
    r0 = 'components'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L15 (error at get_tuple_strategy:168) else goto L1
L1:
    r2 = cast(tuple, r1)
    if is_error(r2) goto L15 (error at get_tuple_strategy:168) else goto L2
L2:
    r3 = get_element_ptr r2 ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = PyList_New(r4)
    if is_error(r5) goto L16 (error at get_tuple_strategy:166) else goto L3
L3:
    r6 = get_element_ptr r2 ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    r8 = 0
L4:
    r9 = r8 < r7 :: signed
    if r9 goto L5 else goto L17 :: bool
L5:
    r10 = CPySequenceTuple_GetItemUnsafe(r2, r8)
    r11 = 'to_type_str'
    r12 = [r10]
    r13 = load_address r12
    r14 = PyObject_VectorcallMethod(r11, r13, 9223372036854775809, 0)
    if is_error(r14) goto L18 (error at get_tuple_strategy:167) else goto L6
L6:
    dec_ref r10
    r15 = cast(str, r14)
    if is_error(r15) goto L19 (error at get_tuple_strategy:167) else goto L7
L7:
    r16 = registry.get_strategy(r15)
    dec_ref r15
    if is_error(r16) goto L19 (error at get_tuple_strategy:167) else goto L8
L8:
    CPyList_SetItemUnsafe(r5, r8, r16)
L9:
    r17 = r8 + 1
    r8 = r17
    goto L4
L10:
    r18 = faster_eth_abi.tools._strategies.globals :: static
    r19 = 'st'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L20 (error at get_tuple_strategy:171) else goto L11
L11:
    r21 = 'tuples'
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    if is_error(r22) goto L20 (error at get_tuple_strategy:171) else goto L12
L12:
    r23 = PyList_AsTuple(r5)
    dec_ref r5
    if is_error(r23) goto L21 (error at get_tuple_strategy:171) else goto L13
L13:
    r24 = PyObject_CallObject(r22, r23)
    dec_ref r22
    dec_ref r23
    if is_error(r24) goto L15 (error at get_tuple_strategy:171) else goto L14
L14:
    return r24
L15:
    r25 = <error> :: object
    return r25
L16:
    dec_ref r2
    goto L15
L17:
    dec_ref r2
    goto L10
L18:
    dec_ref r2
    dec_ref r5
    dec_ref r10
    goto L15
L19:
    dec_ref r2
    dec_ref r5
    goto L15
L20:
    dec_ref r5
    goto L15
L21:
    dec_ref r22
    goto L15

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17, r18 :: object
    r19 :: str
    r20 :: dict
    r21, r22 :: object
    r23 :: str
    r24 :: dict
    r25, r26 :: object
    r27 :: str
    r28 :: dict
    r29, r30 :: object
    r31 :: str
    r32 :: dict
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: tuple[list, object]
    r51, r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58 :: str
    r59 :: object
    r60 :: dict
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: tuple[object, object]
    r69, r70 :: object
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: tuple
    r79 :: str
    r80, r81 :: object
    r82 :: bool
    r83, r84, r85 :: str
    r86 :: tuple
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: i32
    r92 :: bit
    r93 :: dict
    r94 :: str
    r95 :: object
    r96 :: str
    r97, r98 :: object
    r99 :: object[3]
    r100 :: object_ptr
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: str
    r107 :: object[2]
    r108 :: object_ptr
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: i32
    r113 :: bit
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: str
    r118 :: object[1]
    r119 :: object_ptr
    r120 :: object
    r121 :: dict
    r122 :: str
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: str
    r129, r130 :: object
    r131 :: object[3]
    r132 :: object_ptr
    r133, r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: i32
    r138 :: bit
    r139 :: dict
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: object[1]
    r144 :: object_ptr
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: i32
    r149 :: bit
    r150 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r151 :: dict
    r152 :: str
    r153 :: i32
    r154 :: bit
    r155 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r156 :: bool
    r157 :: str
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: object[1]
    r162 :: object_ptr
    r163 :: object
    r164 :: dict
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: None
    r169 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r170 :: bool
    r171 :: str
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: object[1]
    r176 :: object_ptr
    r177 :: object
    r178 :: dict
    r179 :: str
    r180 :: object
    r181 :: str
    r182 :: None
    r183 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r184 :: bool
    r185 :: str
    r186 :: dict
    r187 :: str
    r188, r189 :: object
    r190 :: object[2]
    r191 :: object_ptr
    r192, r193, r194 :: object
    r195 :: bool
    r196 :: str
    r197 :: None
    r198 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r199 :: bool
    r200 :: str
    r201 :: dict
    r202 :: str
    r203, r204 :: object
    r205 :: object[2]
    r206 :: object_ptr
    r207, r208, r209 :: object
    r210 :: bool
    r211 :: str
    r212 :: None
    r213 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r214 :: bool
    r215 :: str
    r216 :: dict
    r217 :: str
    r218 :: object
    r219 :: object[1]
    r220 :: object_ptr
    r221 :: object
    r222 :: dict
    r223 :: str
    r224 :: object
    r225 :: str
    r226 :: None
    r227 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r228 :: bool
    r229 :: str
    r230 :: dict
    r231 :: str
    r232 :: object
    r233 :: object[1]
    r234 :: object_ptr
    r235 :: object
    r236 :: dict
    r237 :: str
    r238 :: object
    r239 :: str
    r240 :: None
    r241 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r242 :: bool
    r243 :: str
    r244 :: dict
    r245 :: str
    r246, r247 :: object
    r248 :: object[2]
    r249 :: object_ptr
    r250, r251 :: object
    r252 :: dict
    r253 :: str
    r254 :: object
    r255 :: str
    r256 :: None
    r257 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r258 :: bool
    r259 :: str
    r260 :: dict
    r261 :: str
    r262, r263 :: object
    r264 :: object[2]
    r265 :: object_ptr
    r266, r267, r268 :: object
    r269 :: bool
    r270 :: str
    r271 :: None
    r272 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r273 :: bool
    r274 :: str
    r275 :: dict
    r276 :: str
    r277, r278 :: object
    r279 :: object[2]
    r280 :: object_ptr
    r281, r282 :: object
    r283 :: dict
    r284 :: str
    r285 :: object
    r286 :: str
    r287 :: None
    r288 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r289 :: bool
    r290 :: str
    r291 :: dict
    r292 :: str
    r293, r294 :: object
    r295 :: object[2]
    r296 :: object_ptr
    r297, r298, r299 :: object
    r300 :: bool
    r301 :: str
    r302 :: None
    r303 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r304 :: bool
    r305 :: dict
    r306 :: str
    r307 :: object
    r308 :: dict
    r309 :: str
    r310 :: object
    r311 :: str
    r312 :: None
    r313 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r314 :: bool
    r315 :: dict
    r316 :: str
    r317 :: object
    r318 :: dict
    r319 :: str
    r320 :: object
    r321 :: str
    r322 :: None
    r323 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r324 :: bool
    r325 :: str
    r326 :: object
    r327 :: dict
    r328 :: str
    r329 :: i32
    r330 :: bit
    r331 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L142 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Callable', 'Final', 'Optional', 'Union')
    r6 = 'typing'
    r7 = faster_eth_abi.tools._strategies.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L142 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('to_checksum_address',)
    r10 = 'cchecksum'
    r11 = faster_eth_abi.tools._strategies.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L142 (error at <module>:8) else goto L5
L5:
    cchecksum = r12 :: module
    dec_ref r12
    r13 = ('TypeStr',)
    r14 = 'eth_typing.abi'
    r15 = faster_eth_abi.tools._strategies.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L142 (error at <module>:11) else goto L6
L6:
    eth_typing.abi = r16 :: module
    dec_ref r16
    r17 = ('strategies',)
    r18 = ('st',)
    r19 = 'hypothesis'
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = CPyImport_ImportFromMany(r19, r17, r18, r20)
    if is_error(r21) goto L142 (error at <module>:14) else goto L7
L7:
    hypothesis = r21 :: module
    dec_ref r21
    r22 = ('ABIType', 'BasicType', 'TupleType', 'normalize', 'parse')
    r23 = 'faster_eth_abi.grammar'
    r24 = faster_eth_abi.tools._strategies.globals :: static
    r25 = CPyImport_ImportFromMany(r23, r22, r22, r24)
    if is_error(r25) goto L142 (error at <module>:18) else goto L8
L8:
    faster_eth_abi.grammar = r25 :: module
    dec_ref r25
    r26 = ('BaseEquals', 'BaseRegistry', 'Lookup', 'PredicateMapping', 'has_arrlist', 'is_base_tuple')
    r27 = 'faster_eth_abi.registry'
    r28 = faster_eth_abi.tools._strategies.globals :: static
    r29 = CPyImport_ImportFromMany(r27, r26, r26, r28)
    if is_error(r29) goto L142 (error at <module>:25) else goto L9
L9:
    faster_eth_abi.registry = r29 :: module
    dec_ref r29
    r30 = ('scale_places',)
    r31 = 'faster_eth_abi.utils.numeric'
    r32 = faster_eth_abi.tools._strategies.globals :: static
    r33 = CPyImport_ImportFromMany(r31, r30, r30, r32)
    if is_error(r33) goto L142 (error at <module>:33) else goto L10
L10:
    faster_eth_abi.utils.numeric = r33 :: module
    dec_ref r33
    r34 = faster_eth_abi.tools._strategies.globals :: static
    r35 = 'Callable'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L142 (error at <module>:37) else goto L11
L11:
    r37 = faster_eth_abi.tools._strategies.globals :: static
    r38 = 'ABIType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L143 (error at <module>:37) else goto L12
L12:
    r40 = 'StrategyRegistry'
    r41 = PyList_New(2)
    if is_error(r41) goto L144 (error at <module>:37) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = faster_eth_abi.tools._strategies.globals :: static
    r46 = 'st'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L145 (error at <module>:37) else goto L14
L14:
    r48 = 'SearchStrategy'
    r49 = CPyObject_GetAttr(r47, r48)
    dec_ref r47
    if is_error(r49) goto L145 (error at <module>:37) else goto L15
L15:
    r50 = (r41, r49)
    r51 = box(tuple[list, object], r50)
    r52 = PyObject_GetItem(r36, r51)
    dec_ref r36
    dec_ref r51
    if is_error(r52) goto L142 (error at <module>:37) else goto L16
L16:
    r53 = faster_eth_abi.tools._strategies.globals :: static
    r54 = 'StrategyFactory'
    r55 = CPyDict_SetItem(r53, r54, r52)
    dec_ref r52
    r56 = r55 >= 0 :: signed
    if not r56 goto L142 (error at <module>:37) else goto L17 :: bool
L17:
    r57 = faster_eth_abi.tools._strategies.globals :: static
    r58 = 'Union'
    r59 = CPyDict_GetItem(r57, r58)
    if is_error(r59) goto L142 (error at <module>:38) else goto L18
L18:
    r60 = faster_eth_abi.tools._strategies.globals :: static
    r61 = 'st'
    r62 = CPyDict_GetItem(r60, r61)
    if is_error(r62) goto L146 (error at <module>:38) else goto L19
L19:
    r63 = 'SearchStrategy'
    r64 = CPyObject_GetAttr(r62, r63)
    dec_ref r62
    if is_error(r64) goto L146 (error at <module>:38) else goto L20
L20:
    r65 = faster_eth_abi.tools._strategies.globals :: static
    r66 = 'StrategyFactory'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L147 (error at <module>:38) else goto L21
L21:
    r68 = (r64, r67)
    r69 = box(tuple[object, object], r68)
    r70 = PyObject_GetItem(r59, r69)
    dec_ref r59
    dec_ref r69
    if is_error(r70) goto L142 (error at <module>:38) else goto L22
L22:
    r71 = faster_eth_abi.tools._strategies.globals :: static
    r72 = 'StrategyRegistration'
    r73 = CPyDict_SetItem(r71, r72, r70)
    dec_ref r70
    r74 = r73 >= 0 :: signed
    if not r74 goto L142 (error at <module>:38) else goto L23 :: bool
L23:
    r75 = faster_eth_abi.tools._strategies.globals :: static
    r76 = 'BaseRegistry'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L142 (error at <module>:41) else goto L24
L24:
    r78 = PyTuple_Pack(1, r77)
    dec_ref r77
    if is_error(r78) goto L142 (error at <module>:41) else goto L25
L25:
    r79 = 'faster_eth_abi.tools._strategies'
    r80 = faster_eth_abi.tools._strategies.StrategyRegistry_template :: type
    r81 = CPyType_FromTemplate(r80, r78, r79)
    dec_ref r78
    if is_error(r81) goto L142 (error at <module>:41) else goto L26
L26:
    r82 = StrategyRegistry_trait_vtable_setup()
    if is_error(r82) goto L148 (error at <module>:-1) else goto L27
L27:
    r83 = '__mypyc_attrs__'
    r84 = '_strategies'
    r85 = '__dict__'
    r86 = PyTuple_Pack(2, r84, r85)
    if is_error(r86) goto L148 (error at <module>:41) else goto L28
L28:
    r87 = PyObject_SetAttr(r81, r83, r86)
    dec_ref r86
    r88 = r87 >= 0 :: signed
    if not r88 goto L148 (error at <module>:41) else goto L29 :: bool
L29:
    faster_eth_abi.tools._strategies.StrategyRegistry = r81 :: type
    r89 = faster_eth_abi.tools._strategies.globals :: static
    r90 = 'StrategyRegistry'
    r91 = PyDict_SetItem(r89, r90, r81)
    dec_ref r81
    r92 = r91 >= 0 :: signed
    if not r92 goto L142 (error at <module>:41) else goto L30 :: bool
L30:
    r93 = faster_eth_abi.tools._strategies.globals :: static
    r94 = 'st'
    r95 = CPyDict_GetItem(r93, r94)
    if is_error(r95) goto L142 (error at <module>:103) else goto L31
L31:
    r96 = 'binary'
    r97 = object 20
    r98 = object 20
    r99 = [r95, r97, r98]
    r100 = load_address r99
    r101 = ('min_size', 'max_size')
    r102 = PyObject_VectorcallMethod(r96, r100, 9223372036854775809, r101)
    if is_error(r102) goto L149 (error at <module>:103) else goto L32
L32:
    dec_ref r95
    r103 = faster_eth_abi.tools._strategies.globals :: static
    r104 = 'to_checksum_address'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L150 (error at <module>:103) else goto L33
L33:
    r106 = 'map'
    r107 = [r102, r105]
    r108 = load_address r107
    r109 = PyObject_VectorcallMethod(r106, r108, 9223372036854775810, 0)
    if is_error(r109) goto L151 (error at <module>:103) else goto L34
L34:
    dec_ref r102
    dec_ref r105
    faster_eth_abi.tools._strategies.address_strategy = r109 :: static
    r110 = faster_eth_abi.tools._strategies.globals :: static
    r111 = 'address_strategy'
    r112 = CPyDict_SetItem(r110, r111, r109)
    dec_ref r109
    r113 = r112 >= 0 :: signed
    if not r113 goto L142 (error at <module>:103) else goto L35 :: bool
L35:
    r114 = faster_eth_abi.tools._strategies.globals :: static
    r115 = 'st'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L142 (error at <module>:104) else goto L36
L36:
    r117 = 'booleans'
    r118 = [r116]
    r119 = load_address r118
    r120 = PyObject_VectorcallMethod(r117, r119, 9223372036854775809, 0)
    if is_error(r120) goto L152 (error at <module>:104) else goto L37
L37:
    dec_ref r116
    faster_eth_abi.tools._strategies.bool_strategy = r120 :: static
    r121 = faster_eth_abi.tools._strategies.globals :: static
    r122 = 'bool_strategy'
    r123 = CPyDict_SetItem(r121, r122, r120)
    dec_ref r120
    r124 = r123 >= 0 :: signed
    if not r124 goto L142 (error at <module>:104) else goto L38 :: bool
L38:
    r125 = faster_eth_abi.tools._strategies.globals :: static
    r126 = 'st'
    r127 = CPyDict_GetItem(r125, r126)
    if is_error(r127) goto L142 (error at <module>:142) else goto L39
L39:
    r128 = 'binary'
    r129 = object 0
    r130 = object 4096
    r131 = [r127, r129, r130]
    r132 = load_address r131
    r133 = ('min_size', 'max_size')
    r134 = PyObject_VectorcallMethod(r128, r132, 9223372036854775809, r133)
    if is_error(r134) goto L153 (error at <module>:142) else goto L40
L40:
    dec_ref r127
    faster_eth_abi.tools._strategies.bytes_strategy = r134 :: static
    r135 = faster_eth_abi.tools._strategies.globals :: static
    r136 = 'bytes_strategy'
    r137 = CPyDict_SetItem(r135, r136, r134)
    dec_ref r134
    r138 = r137 >= 0 :: signed
    if not r138 goto L142 (error at <module>:142) else goto L41 :: bool
L41:
    r139 = faster_eth_abi.tools._strategies.globals :: static
    r140 = 'st'
    r141 = CPyDict_GetItem(r139, r140)
    if is_error(r141) goto L142 (error at <module>:143) else goto L42
L42:
    r142 = 'text'
    r143 = [r141]
    r144 = load_address r143
    r145 = PyObject_VectorcallMethod(r142, r144, 9223372036854775809, 0)
    if is_error(r145) goto L154 (error at <module>:143) else goto L43
L43:
    dec_ref r141
    faster_eth_abi.tools._strategies.string_strategy = r145 :: static
    r146 = faster_eth_abi.tools._strategies.globals :: static
    r147 = 'string_strategy'
    r148 = CPyDict_SetItem(r146, r147, r145)
    dec_ref r145
    r149 = r148 >= 0 :: signed
    if not r149 goto L142 (error at <module>:143) else goto L44 :: bool
L44:
    r150 = StrategyRegistry()
    if is_error(r150) goto L142 (error at <module>:174) else goto L45
L45:
    faster_eth_abi.tools._strategies.strategy_registry = r150 :: static
    r151 = faster_eth_abi.tools._strategies.globals :: static
    r152 = 'strategy_registry'
    r153 = CPyDict_SetItem(r151, r152, r150)
    dec_ref r150
    r154 = r153 >= 0 :: signed
    if not r154 goto L142 (error at <module>:174) else goto L46 :: bool
L46:
    r155 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r155) goto L47 else goto L49
L47:
    r156 = raise NameError('value for final name "strategy_registry" was not set')
    if not r156 goto L142 (error at <module>:176) else goto L48 :: bool
L48:
    unreachable
L49:
    r157 = 'uint'
    r158 = faster_eth_abi.tools._strategies.globals :: static
    r159 = 'BaseEquals'
    r160 = CPyDict_GetItem(r158, r159)
    if is_error(r160) goto L142 (error at <module>:177) else goto L50
L50:
    r161 = [r157]
    r162 = load_address r161
    r163 = PyObject_Vectorcall(r160, r162, 1, 0)
    dec_ref r160
    if is_error(r163) goto L142 (error at <module>:177) else goto L51
L51:
    r164 = faster_eth_abi.tools._strategies.globals :: static
    r165 = 'get_uint_strategy'
    r166 = CPyDict_GetItem(r164, r165)
    if is_error(r166) goto L155 (error at <module>:178) else goto L52
L52:
    r167 = 'uint'
    r168 = r155.register_strategy(r163, r166, r167)
    dec_ref r163
    dec_ref r166
    if is_error(r168) goto L142 (error at <module>:176) else goto L53
L53:
    r169 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r169) goto L54 else goto L56
L54:
    r170 = raise NameError('value for final name "strategy_registry" was not set')
    if not r170 goto L142 (error at <module>:181) else goto L55 :: bool
L55:
    unreachable
L56:
    r171 = 'int'
    r172 = faster_eth_abi.tools._strategies.globals :: static
    r173 = 'BaseEquals'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L142 (error at <module>:182) else goto L57
L57:
    r175 = [r171]
    r176 = load_address r175
    r177 = PyObject_Vectorcall(r174, r176, 1, 0)
    dec_ref r174
    if is_error(r177) goto L142 (error at <module>:182) else goto L58
L58:
    r178 = faster_eth_abi.tools._strategies.globals :: static
    r179 = 'get_int_strategy'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L156 (error at <module>:183) else goto L59
L59:
    r181 = 'int'
    r182 = r169.register_strategy(r177, r180, r181)
    dec_ref r177
    dec_ref r180
    if is_error(r182) goto L142 (error at <module>:181) else goto L60
L60:
    r183 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r183) goto L61 else goto L63
L61:
    r184 = raise NameError('value for final name "strategy_registry" was not set')
    if not r184 goto L142 (error at <module>:186) else goto L62 :: bool
L62:
    unreachable
L63:
    r185 = 'address'
    r186 = faster_eth_abi.tools._strategies.globals :: static
    r187 = 'BaseEquals'
    r188 = CPyDict_GetItem(r186, r187)
    if is_error(r188) goto L142 (error at <module>:187) else goto L64
L64:
    r189 = box(bool, 0)
    r190 = [r185, r189]
    r191 = load_address r190
    r192 = ('with_sub',)
    r193 = PyObject_Vectorcall(r188, r191, 1, r192)
    dec_ref r188
    if is_error(r193) goto L142 (error at <module>:187) else goto L65
L65:
    r194 = faster_eth_abi.tools._strategies.address_strategy :: static
    if is_error(r194) goto L157 else goto L68
L66:
    r195 = raise NameError('value for final name "address_strategy" was not set')
    if not r195 goto L142 (error at <module>:188) else goto L67 :: bool
L67:
    unreachable
L68:
    r196 = 'address'
    r197 = r183.register_strategy(r193, r194, r196)
    dec_ref r193
    if is_error(r197) goto L142 (error at <module>:186) else goto L69
L69:
    r198 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r198) goto L70 else goto L72
L70:
    r199 = raise NameError('value for final name "strategy_registry" was not set')
    if not r199 goto L142 (error at <module>:191) else goto L71 :: bool
L71:
    unreachable
L72:
    r200 = 'bool'
    r201 = faster_eth_abi.tools._strategies.globals :: static
    r202 = 'BaseEquals'
    r203 = CPyDict_GetItem(r201, r202)
    if is_error(r203) goto L142 (error at <module>:192) else goto L73
L73:
    r204 = box(bool, 0)
    r205 = [r200, r204]
    r206 = load_address r205
    r207 = ('with_sub',)
    r208 = PyObject_Vectorcall(r203, r206, 1, r207)
    dec_ref r203
    if is_error(r208) goto L142 (error at <module>:192) else goto L74
L74:
    r209 = faster_eth_abi.tools._strategies.bool_strategy :: static
    if is_error(r209) goto L158 else goto L77
L75:
    r210 = raise NameError('value for final name "bool_strategy" was not set')
    if not r210 goto L142 (error at <module>:193) else goto L76 :: bool
L76:
    unreachable
L77:
    r211 = 'bool'
    r212 = r198.register_strategy(r208, r209, r211)
    dec_ref r208
    if is_error(r212) goto L142 (error at <module>:191) else goto L78
L78:
    r213 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r213) goto L79 else goto L81
L79:
    r214 = raise NameError('value for final name "strategy_registry" was not set')
    if not r214 goto L142 (error at <module>:196) else goto L80 :: bool
L80:
    unreachable
L81:
    r215 = 'ufixed'
    r216 = faster_eth_abi.tools._strategies.globals :: static
    r217 = 'BaseEquals'
    r218 = CPyDict_GetItem(r216, r217)
    if is_error(r218) goto L142 (error at <module>:197) else goto L82
L82:
    r219 = [r215]
    r220 = load_address r219
    r221 = PyObject_Vectorcall(r218, r220, 1, 0)
    dec_ref r218
    if is_error(r221) goto L142 (error at <module>:197) else goto L83
L83:
    r222 = faster_eth_abi.tools._strategies.globals :: static
    r223 = 'get_ufixed_strategy'
    r224 = CPyDict_GetItem(r222, r223)
    if is_error(r224) goto L159 (error at <module>:198) else goto L84
L84:
    r225 = 'ufixed'
    r226 = r213.register_strategy(r221, r224, r225)
    dec_ref r221
    dec_ref r224
    if is_error(r226) goto L142 (error at <module>:196) else goto L85
L85:
    r227 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r227) goto L86 else goto L88
L86:
    r228 = raise NameError('value for final name "strategy_registry" was not set')
    if not r228 goto L142 (error at <module>:201) else goto L87 :: bool
L87:
    unreachable
L88:
    r229 = 'fixed'
    r230 = faster_eth_abi.tools._strategies.globals :: static
    r231 = 'BaseEquals'
    r232 = CPyDict_GetItem(r230, r231)
    if is_error(r232) goto L142 (error at <module>:202) else goto L89
L89:
    r233 = [r229]
    r234 = load_address r233
    r235 = PyObject_Vectorcall(r232, r234, 1, 0)
    dec_ref r232
    if is_error(r235) goto L142 (error at <module>:202) else goto L90
L90:
    r236 = faster_eth_abi.tools._strategies.globals :: static
    r237 = 'get_fixed_strategy'
    r238 = CPyDict_GetItem(r236, r237)
    if is_error(r238) goto L160 (error at <module>:203) else goto L91
L91:
    r239 = 'fixed'
    r240 = r227.register_strategy(r235, r238, r239)
    dec_ref r235
    dec_ref r238
    if is_error(r240) goto L142 (error at <module>:201) else goto L92
L92:
    r241 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r241) goto L93 else goto L95
L93:
    r242 = raise NameError('value for final name "strategy_registry" was not set')
    if not r242 goto L142 (error at <module>:206) else goto L94 :: bool
L94:
    unreachable
L95:
    r243 = 'bytes'
    r244 = faster_eth_abi.tools._strategies.globals :: static
    r245 = 'BaseEquals'
    r246 = CPyDict_GetItem(r244, r245)
    if is_error(r246) goto L142 (error at <module>:207) else goto L96
L96:
    r247 = box(bool, 1)
    r248 = [r243, r247]
    r249 = load_address r248
    r250 = ('with_sub',)
    r251 = PyObject_Vectorcall(r246, r249, 1, r250)
    dec_ref r246
    if is_error(r251) goto L142 (error at <module>:207) else goto L97
L97:
    r252 = faster_eth_abi.tools._strategies.globals :: static
    r253 = 'get_bytes_strategy'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L161 (error at <module>:208) else goto L98
L98:
    r255 = 'bytes<M>'
    r256 = r241.register_strategy(r251, r254, r255)
    dec_ref r251
    dec_ref r254
    if is_error(r256) goto L142 (error at <module>:206) else goto L99
L99:
    r257 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r257) goto L100 else goto L102
L100:
    r258 = raise NameError('value for final name "strategy_registry" was not set')
    if not r258 goto L142 (error at <module>:211) else goto L101 :: bool
L101:
    unreachable
L102:
    r259 = 'bytes'
    r260 = faster_eth_abi.tools._strategies.globals :: static
    r261 = 'BaseEquals'
    r262 = CPyDict_GetItem(r260, r261)
    if is_error(r262) goto L142 (error at <module>:212) else goto L103
L103:
    r263 = box(bool, 0)
    r264 = [r259, r263]
    r265 = load_address r264
    r266 = ('with_sub',)
    r267 = PyObject_Vectorcall(r262, r265, 1, r266)
    dec_ref r262
    if is_error(r267) goto L142 (error at <module>:212) else goto L104
L104:
    r268 = faster_eth_abi.tools._strategies.bytes_strategy :: static
    if is_error(r268) goto L162 else goto L107
L105:
    r269 = raise NameError('value for final name "bytes_strategy" was not set')
    if not r269 goto L142 (error at <module>:213) else goto L106 :: bool
L106:
    unreachable
L107:
    r270 = 'bytes'
    r271 = r257.register_strategy(r267, r268, r270)
    dec_ref r267
    if is_error(r271) goto L142 (error at <module>:211) else goto L108
L108:
    r272 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r272) goto L109 else goto L111
L109:
    r273 = raise NameError('value for final name "strategy_registry" was not set')
    if not r273 goto L142 (error at <module>:216) else goto L110 :: bool
L110:
    unreachable
L111:
    r274 = 'function'
    r275 = faster_eth_abi.tools._strategies.globals :: static
    r276 = 'BaseEquals'
    r277 = CPyDict_GetItem(r275, r276)
    if is_error(r277) goto L142 (error at <module>:217) else goto L112
L112:
    r278 = box(bool, 0)
    r279 = [r274, r278]
    r280 = load_address r279
    r281 = ('with_sub',)
    r282 = PyObject_Vectorcall(r277, r280, 1, r281)
    dec_ref r277
    if is_error(r282) goto L142 (error at <module>:217) else goto L113
L113:
    r283 = faster_eth_abi.tools._strategies.globals :: static
    r284 = 'get_bytes_strategy'
    r285 = CPyDict_GetItem(r283, r284)
    if is_error(r285) goto L163 (error at <module>:218) else goto L114
L114:
    r286 = 'function'
    r287 = r272.register_strategy(r282, r285, r286)
    dec_ref r282
    dec_ref r285
    if is_error(r287) goto L142 (error at <module>:216) else goto L115
L115:
    r288 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r288) goto L116 else goto L118
L116:
    r289 = raise NameError('value for final name "strategy_registry" was not set')
    if not r289 goto L142 (error at <module>:221) else goto L117 :: bool
L117:
    unreachable
L118:
    r290 = 'string'
    r291 = faster_eth_abi.tools._strategies.globals :: static
    r292 = 'BaseEquals'
    r293 = CPyDict_GetItem(r291, r292)
    if is_error(r293) goto L142 (error at <module>:222) else goto L119
L119:
    r294 = box(bool, 0)
    r295 = [r290, r294]
    r296 = load_address r295
    r297 = ('with_sub',)
    r298 = PyObject_Vectorcall(r293, r296, 1, r297)
    dec_ref r293
    if is_error(r298) goto L142 (error at <module>:222) else goto L120
L120:
    r299 = faster_eth_abi.tools._strategies.string_strategy :: static
    if is_error(r299) goto L164 else goto L123
L121:
    r300 = raise NameError('value for final name "string_strategy" was not set')
    if not r300 goto L142 (error at <module>:223) else goto L122 :: bool
L122:
    unreachable
L123:
    r301 = 'string'
    r302 = r288.register_strategy(r298, r299, r301)
    dec_ref r298
    if is_error(r302) goto L142 (error at <module>:221) else goto L124
L124:
    r303 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r303) goto L125 else goto L127
L125:
    r304 = raise NameError('value for final name "strategy_registry" was not set')
    if not r304 goto L142 (error at <module>:226) else goto L126 :: bool
L126:
    unreachable
L127:
    r305 = faster_eth_abi.tools._strategies.globals :: static
    r306 = 'has_arrlist'
    r307 = CPyDict_GetItem(r305, r306)
    if is_error(r307) goto L142 (error at <module>:227) else goto L128
L128:
    r308 = faster_eth_abi.tools._strategies.globals :: static
    r309 = 'get_array_strategy'
    r310 = CPyDict_GetItem(r308, r309)
    if is_error(r310) goto L165 (error at <module>:228) else goto L129
L129:
    r311 = 'has_arrlist'
    r312 = r303.register_strategy(r307, r310, r311)
    dec_ref r307
    dec_ref r310
    if is_error(r312) goto L142 (error at <module>:226) else goto L130
L130:
    r313 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r313) goto L131 else goto L133
L131:
    r314 = raise NameError('value for final name "strategy_registry" was not set')
    if not r314 goto L142 (error at <module>:231) else goto L132 :: bool
L132:
    unreachable
L133:
    r315 = faster_eth_abi.tools._strategies.globals :: static
    r316 = 'is_base_tuple'
    r317 = CPyDict_GetItem(r315, r316)
    if is_error(r317) goto L142 (error at <module>:232) else goto L134
L134:
    r318 = faster_eth_abi.tools._strategies.globals :: static
    r319 = 'get_tuple_strategy'
    r320 = CPyDict_GetItem(r318, r319)
    if is_error(r320) goto L166 (error at <module>:233) else goto L135
L135:
    r321 = 'is_base_tuple'
    r322 = r313.register_strategy(r317, r320, r321)
    dec_ref r317
    dec_ref r320
    if is_error(r322) goto L142 (error at <module>:231) else goto L136
L136:
    r323 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r323) goto L137 else goto L139
L137:
    r324 = raise NameError('value for final name "strategy_registry" was not set')
    if not r324 goto L142 (error at <module>:237) else goto L138 :: bool
L138:
    unreachable
L139:
    r325 = 'get_strategy'
    r326 = CPyObject_GetAttr(r323, r325)
    if is_error(r326) goto L142 (error at <module>:237) else goto L140
L140:
    faster_eth_abi.tools._strategies.get_abi_strategy = r326 :: static
    r327 = faster_eth_abi.tools._strategies.globals :: static
    r328 = 'get_abi_strategy'
    r329 = CPyDict_SetItem(r327, r328, r326)
    dec_ref r326
    r330 = r329 >= 0 :: signed
    if not r330 goto L142 (error at <module>:237) else goto L141 :: bool
L141:
    return 1
L142:
    r331 = <error> :: None
    return r331
L143:
    dec_ref r36
    goto L142
L144:
    dec_ref r36
    dec_ref r39
    goto L142
L145:
    dec_ref r36
    dec_ref r41
    goto L142
L146:
    dec_ref r59
    goto L142
L147:
    dec_ref r59
    dec_ref r64
    goto L142
L148:
    dec_ref r81
    goto L142
L149:
    dec_ref r95
    goto L142
L150:
    dec_ref r102
    goto L142
L151:
    dec_ref r102
    dec_ref r105
    goto L142
L152:
    dec_ref r116
    goto L142
L153:
    dec_ref r127
    goto L142
L154:
    dec_ref r141
    goto L142
L155:
    dec_ref r163
    goto L142
L156:
    dec_ref r177
    goto L142
L157:
    dec_ref r193
    goto L66
L158:
    dec_ref r208
    goto L75
L159:
    dec_ref r221
    goto L142
L160:
    dec_ref r235
    goto L142
L161:
    dec_ref r251
    goto L142
L162:
    dec_ref r267
    goto L105
L163:
    dec_ref r282
    goto L142
L164:
    dec_ref r298
    goto L121
L165:
    dec_ref r307
    goto L142
L166:
    dec_ref r317
    goto L142

def ceil32(x):
    x, r0 :: int
    r1 :: bit
    r2, r3, r4, r5, r6 :: int
L0:
    r0 = CPyTagged_Remainder(x, 64)
    if is_error(r0) goto L6 (error at ceil32:19) else goto L1
L1:
    r1 = r0 == 0
    dec_ref r0 :: int
    if r1 goto L2 else goto L3 :: bool
L2:
    inc_ref x :: int
    r2 = x
    goto L5
L3:
    r3 = CPyTagged_Add(x, 64)
    r4 = CPyTagged_Remainder(x, 64)
    if is_error(r4) goto L7 (error at ceil32:19) else goto L4
L4:
    r5 = CPyTagged_Subtract(r3, r4)
    dec_ref r3 :: int
    dec_ref r4 :: int
    r2 = r5
L5:
    return r2
L6:
    r6 = <error> :: int
    return r6
L7:
    dec_ref r3 :: int
    goto L6

def compute_unsigned_integer_bounds(num_bits):
    num_bits :: int
    r0, r1, r2, r3, r4 :: object
    r5 :: tuple[int, object]
    r6 :: int
    r7, r8 :: tuple[int, int]
L0:
    r0 = object 2
    inc_ref num_bits :: int
    r1 = box(int, num_bits)
    r2 = CPyNumber_Power(r0, r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at compute_unsigned_integer_bounds:25) else goto L1
L1:
    r3 = object 1
    r4 = PyNumber_Subtract(r2, r3)
    dec_ref r2
    if is_error(r4) goto L4 (error at compute_unsigned_integer_bounds:25) else goto L2
L2:
    inc_ref r4
    r5 = (0, r4)
    dec_ref r5
    r6 = unbox(int, r4)
    dec_ref r4
    if is_error(r6) goto L4 (error at compute_unsigned_integer_bounds:23) else goto L3
L3:
    r7 = (0, r6)
    return r7
L4:
    r8 = <error> :: tuple[int, int]
    return r8

def compute_signed_integer_bounds(num_bits):
    num_bits, r0 :: int
    r1, r2, r3, r4, r5 :: object
    r6 :: int
    r7, r8, r9, r10, r11 :: object
    r12 :: tuple[object, object]
    r13, r14 :: int
    r15, r16 :: tuple[int, int]
L0:
    r0 = CPyTagged_Subtract(num_bits, 2)
    r1 = object 2
    r2 = box(int, r0)
    r3 = CPyNumber_Power(r1, r2)
    dec_ref r2
    if is_error(r3) goto L7 (error at compute_signed_integer_bounds:31) else goto L1
L1:
    r4 = object -1
    r5 = PyNumber_Multiply(r4, r3)
    dec_ref r3
    if is_error(r5) goto L7 (error at compute_signed_integer_bounds:31) else goto L2
L2:
    r6 = CPyTagged_Subtract(num_bits, 2)
    r7 = object 2
    r8 = box(int, r6)
    r9 = CPyNumber_Power(r7, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at compute_signed_integer_bounds:32) else goto L3
L3:
    r10 = object 1
    r11 = PyNumber_Subtract(r9, r10)
    dec_ref r9
    if is_error(r11) goto L8 (error at compute_signed_integer_bounds:32) else goto L4
L4:
    inc_ref r5
    inc_ref r11
    r12 = (r5, r11)
    dec_ref r12
    r13 = unbox(int, r5)
    dec_ref r5
    if is_error(r13) goto L9 (error at compute_signed_integer_bounds:30) else goto L5
L5:
    r14 = unbox(int, r11)
    dec_ref r11
    if is_error(r14) goto L10 (error at compute_signed_integer_bounds:30) else goto L6
L6:
    r15 = (r13, r14)
    return r15
L7:
    r16 = <error> :: tuple[int, int]
    return r16
L8:
    dec_ref r5
    goto L7
L9:
    dec_ref r11
    goto L7
L10:
    dec_ref r13 :: int
    goto L7

def compute_unsigned_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0, upper :: object
    r1 :: tuple[int, int]
    r2 :: int
    r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: bool
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
    r27 :: bool
    r28 :: int
    r29, r30, r31 :: object
    r32, r33 :: tuple[object, object, object]
    r34, r35, r36 :: object
    r37 :: object[4]
    r38 :: object_ptr
    r39 :: object
    r40 :: i32
    r41 :: bit
    r42 :: bool
    r43 :: bit
    r44, r45, r46 :: tuple[object, object, object]
    r47 :: object
    r48 :: object[4]
    r49 :: object_ptr
    r50 :: object
    r51 :: bit
    r52 :: object
    r53, r54 :: bool
    r55, r56 :: tuple[object, object]
L0:
    r0 = <error> :: object
    upper = r0
    r1 = compute_unsigned_integer_bounds(num_bits)
    if is_error(r1) goto L48 (error at compute_unsigned_fixed_bounds:40) else goto L1
L1:
    r2 = r1[1]
    dec_ref r1
    r3 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r3) goto L49 else goto L4
L2:
    r4 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r4 goto L47 (error at compute_unsigned_fixed_bounds:42) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = decimal :: module
    r6 = 'localcontext'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L50 (error at compute_unsigned_fixed_bounds:42) else goto L5
L5:
    r8 = [r3]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L50 (error at compute_unsigned_fixed_bounds:42) else goto L6
L6:
    r11 = CPy_TYPE(r10)
    r12 = '__exit__'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L51 (error at compute_unsigned_fixed_bounds:42) else goto L7
L7:
    r14 = '__enter__'
    r15 = CPyObject_GetAttr(r11, r14)
    dec_ref r11
    if is_error(r15) goto L52 (error at compute_unsigned_fixed_bounds:42) else goto L8
L8:
    r16 = [r10]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L52 (error at compute_unsigned_fixed_bounds:42) else goto L53
L9:
    r19 = 1
L10:
    r20 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r20) goto L54 else goto L13
L11:
    r21 = raise NameError('value for final name "Decimal" was not set')
    if not r21 goto L20 (error at compute_unsigned_fixed_bounds:43) else goto L55 :: bool
L12:
    unreachable
L13:
    r22 = box(int, r2)
    r23 = [r22]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r20, r24, 1, 0)
    if is_error(r25) goto L56 (error at compute_unsigned_fixed_bounds:43) else goto L14
L14:
    dec_ref r22
    r26 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r26) goto L57 else goto L17
L15:
    r27 = raise NameError('value for final name "TEN" was not set')
    if not r27 goto L20 (error at compute_unsigned_fixed_bounds:43) else goto L58 :: bool
L16:
    unreachable
L17:
    r28 = CPyTagged_Negate(frac_places)
    r29 = box(int, r28)
    r30 = CPyNumber_Power(r26, r29)
    dec_ref r29
    if is_error(r30) goto L59 (error at compute_unsigned_fixed_bounds:43) else goto L18
L18:
    r31 = PyNumber_Multiply(r25, r30)
    dec_ref r25
    dec_ref r30
    if is_error(r31) goto L20 (error at compute_unsigned_fixed_bounds:43) else goto L60
L19:
    upper = r31
    goto L28
L20:
    r32 = CPy_CatchError()
    r19 = 0
    r33 = CPy_GetExcInfo()
    r34 = r33[0]
    r35 = r33[1]
    r36 = r33[2]
    dec_ref r33
    r37 = [r10, r34, r35, r36]
    r38 = load_address r37
    r39 = PyObject_Vectorcall(r13, r38, 4, 0)
    if is_error(r39) goto L61 (error at compute_unsigned_fixed_bounds:42) else goto L21
L21:
    dec_ref r34
    dec_ref r35
    dec_ref r36
    r40 = PyObject_IsTrue(r39)
    dec_ref r39
    r41 = r40 >= 0 :: signed
    if not r41 goto L26 (error at compute_unsigned_fixed_bounds:42) else goto L22 :: bool
L22:
    r42 = truncate r40: i32 to builtins.bool
    if r42 goto L25 else goto L23 :: bool
L23:
    CPy_Reraise()
    if not 0 goto L26 else goto L62 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    goto L28
L26:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    r43 = CPy_KeepPropagating()
    if not r43 goto L29 else goto L63 :: bool
L27:
    unreachable
L28:
    r44 = <error> :: tuple[object, object, object]
    r45 = r44
    goto L30
L29:
    r46 = CPy_CatchError()
    r45 = r46
L30:
    if r19 goto L31 else goto L64 :: bool
L31:
    r47 = load_address _Py_NoneStruct
    r48 = [r10, r47, r47, r47]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r13, r49, 4, 0)
    dec_ref r13
    if is_error(r50) goto L65 (error at compute_unsigned_fixed_bounds:42) else goto L66
L32:
    dec_ref r10
L33:
    if is_error(r45) goto L40 else goto L67
L34:
    CPy_Reraise()
    if not 0 goto L36 else goto L68 :: bool
L35:
    unreachable
L36:
    if is_error(r45) goto L38 else goto L37
L37:
    CPy_RestoreExcInfo(r45)
    xdec_ref r45
L38:
    r51 = CPy_KeepPropagating()
    if not r51 goto L47 else goto L39 :: bool
L39:
    unreachable
L40:
    r52 = faster_eth_abi.utils.numeric.ZERO :: static
    if is_error(r52) goto L69 else goto L43
L41:
    r53 = raise NameError('value for final name "ZERO" was not set')
    if not r53 goto L47 (error at compute_unsigned_fixed_bounds:45) else goto L42 :: bool
L42:
    unreachable
L43:
    if is_error(upper) goto L44 else goto L46
L44:
    r54 = raise UnboundLocalError('local variable "upper" referenced before assignment')
    if not r54 goto L47 (error at compute_unsigned_fixed_bounds:45) else goto L45 :: bool
L45:
    unreachable
L46:
    inc_ref r52
    r55 = (r52, upper)
    return r55
L47:
    r56 = <error> :: tuple[object, object]
    return r56
L48:
    xdec_ref upper
    goto L47
L49:
    xdec_ref upper
    dec_ref r2 :: int
    goto L2
L50:
    xdec_ref upper
    dec_ref r2 :: int
    goto L47
L51:
    xdec_ref upper
    dec_ref r2 :: int
    dec_ref r10
    dec_ref r11
    goto L47
L52:
    xdec_ref upper
    dec_ref r2 :: int
    dec_ref r10
    dec_ref r13
    goto L47
L53:
    dec_ref r18
    goto L9
L54:
    dec_ref r2 :: int
    goto L11
L55:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    goto L12
L56:
    dec_ref r22
    goto L20
L57:
    dec_ref r25
    goto L15
L58:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    goto L16
L59:
    dec_ref r25
    goto L20
L60:
    xdec_ref upper
    goto L19
L61:
    dec_ref r34
    dec_ref r35
    dec_ref r36
    goto L26
L62:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    dec_ref r32
    goto L24
L63:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    goto L27
L64:
    dec_ref r10
    dec_ref r13
    goto L33
L65:
    xdec_ref upper
    dec_ref r10
    goto L36
L66:
    dec_ref r50
    goto L32
L67:
    xdec_ref upper
    goto L34
L68:
    xdec_ref r45
    goto L35
L69:
    xdec_ref upper
    goto L41

def compute_signed_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0, lower, r1, upper :: object
    r2 :: tuple[int, int]
    r3, r4, r5, r6 :: int
    r7 :: object
    r8 :: bool
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[1]
    r13 :: object_ptr
    r14, r15 :: object
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: bool
    r26 :: int
    r27, r28, r29 :: object
    r30 :: bool
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34, r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41, r42 :: object
    r43, r44 :: tuple[object, object, object]
    r45, r46, r47 :: object
    r48 :: object[4]
    r49 :: object_ptr
    r50 :: object
    r51 :: i32
    r52 :: bit
    r53 :: bool
    r54 :: bit
    r55, r56, r57 :: tuple[object, object, object]
    r58 :: object
    r59 :: object[4]
    r60 :: object_ptr
    r61 :: object
    r62 :: bit
    r63, r64 :: bool
    r65, r66 :: tuple[object, object]
L0:
    r0 = <error> :: object
    lower = r0
    r1 = <error> :: object
    upper = r1
    r2 = compute_signed_integer_bounds(num_bits)
    if is_error(r2) goto L53 (error at compute_signed_fixed_bounds:52) else goto L1
L1:
    r3 = borrow r2[0]
    r4 = borrow r2[1]
    r5 = unborrow r3
    r6 = unborrow r4
    r7 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r7) goto L54 else goto L4
L2:
    r8 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r8 goto L52 (error at compute_signed_fixed_bounds:54) else goto L3 :: bool
L3:
    unreachable
L4:
    r9 = decimal :: module
    r10 = 'localcontext'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L55 (error at compute_signed_fixed_bounds:54) else goto L5
L5:
    r12 = [r7]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 1, 0)
    dec_ref r11
    if is_error(r14) goto L55 (error at compute_signed_fixed_bounds:54) else goto L6
L6:
    r15 = CPy_TYPE(r14)
    r16 = '__exit__'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L56 (error at compute_signed_fixed_bounds:54) else goto L7
L7:
    r18 = '__enter__'
    r19 = CPyObject_GetAttr(r15, r18)
    dec_ref r15
    if is_error(r19) goto L57 (error at compute_signed_fixed_bounds:54) else goto L8
L8:
    r20 = [r14]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L57 (error at compute_signed_fixed_bounds:54) else goto L58
L9:
    r23 = 1
L10:
    r24 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r24) goto L59 else goto L13
L11:
    r25 = raise NameError('value for final name "TEN" was not set')
    if not r25 goto L25 (error at compute_signed_fixed_bounds:55) else goto L60 :: bool
L12:
    unreachable
L13:
    r26 = CPyTagged_Negate(frac_places)
    r27 = box(int, r26)
    r28 = CPyNumber_Power(r24, r27)
    dec_ref r27
    if is_error(r28) goto L61 (error at compute_signed_fixed_bounds:55) else goto L14
L14:
    r29 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r29) goto L62 else goto L17
L15:
    r30 = raise NameError('value for final name "Decimal" was not set')
    if not r30 goto L25 (error at compute_signed_fixed_bounds:56) else goto L63 :: bool
L16:
    unreachable
L17:
    r31 = box(int, r5)
    r32 = [r31]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r29, r33, 1, 0)
    if is_error(r34) goto L64 (error at compute_signed_fixed_bounds:56) else goto L18
L18:
    dec_ref r31
    r35 = PyNumber_Multiply(r34, r28)
    dec_ref r34
    if is_error(r35) goto L65 (error at compute_signed_fixed_bounds:56) else goto L66
L19:
    lower = r35
    r36 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r36) goto L67 else goto L22
L20:
    r37 = raise NameError('value for final name "Decimal" was not set')
    if not r37 goto L25 (error at compute_signed_fixed_bounds:57) else goto L68 :: bool
L21:
    unreachable
L22:
    r38 = box(int, r6)
    r39 = [r38]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r36, r40, 1, 0)
    if is_error(r41) goto L69 (error at compute_signed_fixed_bounds:57) else goto L23
L23:
    dec_ref r38
    r42 = PyNumber_Multiply(r41, r28)
    dec_ref r41
    dec_ref r28
    if is_error(r42) goto L25 (error at compute_signed_fixed_bounds:57) else goto L70
L24:
    upper = r42
    goto L33
L25:
    r43 = CPy_CatchError()
    r23 = 0
    r44 = CPy_GetExcInfo()
    r45 = r44[0]
    r46 = r44[1]
    r47 = r44[2]
    dec_ref r44
    r48 = [r14, r45, r46, r47]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r17, r49, 4, 0)
    if is_error(r50) goto L71 (error at compute_signed_fixed_bounds:54) else goto L26
L26:
    dec_ref r45
    dec_ref r46
    dec_ref r47
    r51 = PyObject_IsTrue(r50)
    dec_ref r50
    r52 = r51 >= 0 :: signed
    if not r52 goto L31 (error at compute_signed_fixed_bounds:54) else goto L27 :: bool
L27:
    r53 = truncate r51: i32 to builtins.bool
    if r53 goto L30 else goto L28 :: bool
L28:
    CPy_Reraise()
    if not 0 goto L31 else goto L72 :: bool
L29:
    unreachable
L30:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    goto L33
L31:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    r54 = CPy_KeepPropagating()
    if not r54 goto L34 else goto L73 :: bool
L32:
    unreachable
L33:
    r55 = <error> :: tuple[object, object, object]
    r56 = r55
    goto L35
L34:
    r57 = CPy_CatchError()
    r56 = r57
L35:
    if r23 goto L36 else goto L74 :: bool
L36:
    r58 = load_address _Py_NoneStruct
    r59 = [r14, r58, r58, r58]
    r60 = load_address r59
    r61 = PyObject_Vectorcall(r17, r60, 4, 0)
    dec_ref r17
    if is_error(r61) goto L75 (error at compute_signed_fixed_bounds:54) else goto L76
L37:
    dec_ref r14
L38:
    if is_error(r56) goto L45 else goto L77
L39:
    CPy_Reraise()
    if not 0 goto L41 else goto L78 :: bool
L40:
    unreachable
L41:
    if is_error(r56) goto L43 else goto L42
L42:
    CPy_RestoreExcInfo(r56)
    xdec_ref r56
L43:
    r62 = CPy_KeepPropagating()
    if not r62 goto L52 else goto L44 :: bool
L44:
    unreachable
L45:
    if is_error(lower) goto L79 else goto L48
L46:
    r63 = raise UnboundLocalError('local variable "lower" referenced before assignment')
    if not r63 goto L52 (error at compute_signed_fixed_bounds:59) else goto L47 :: bool
L47:
    unreachable
L48:
    if is_error(upper) goto L80 else goto L51
L49:
    r64 = raise UnboundLocalError('local variable "upper" referenced before assignment')
    if not r64 goto L52 (error at compute_signed_fixed_bounds:59) else goto L50 :: bool
L50:
    unreachable
L51:
    r65 = (lower, upper)
    return r65
L52:
    r66 = <error> :: tuple[object, object]
    return r66
L53:
    xdec_ref lower
    xdec_ref upper
    goto L52
L54:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L2
L55:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L52
L56:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    dec_ref r14
    dec_ref r15
    goto L52
L57:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    dec_ref r14
    dec_ref r17
    goto L52
L58:
    dec_ref r22
    goto L9
L59:
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L11
L60:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L12
L61:
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L25
L62:
    dec_ref r5 :: int
    dec_ref r6 :: int
    dec_ref r28
    goto L15
L63:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L16
L64:
    dec_ref r6 :: int
    dec_ref r28
    dec_ref r31
    goto L25
L65:
    dec_ref r6 :: int
    dec_ref r28
    goto L25
L66:
    xdec_ref lower
    goto L19
L67:
    dec_ref r6 :: int
    dec_ref r28
    goto L20
L68:
    dec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L21
L69:
    dec_ref r28
    dec_ref r38
    goto L25
L70:
    xdec_ref upper
    goto L24
L71:
    dec_ref r45
    dec_ref r46
    dec_ref r47
    goto L31
L72:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    dec_ref r43
    goto L29
L73:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L32
L74:
    dec_ref r14
    dec_ref r17
    goto L38
L75:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    goto L41
L76:
    dec_ref r61
    goto L37
L77:
    xdec_ref lower
    xdec_ref upper
    goto L39
L78:
    xdec_ref r56
    goto L40
L79:
    xdec_ref upper
    goto L46
L80:
    xdec_ref lower
    goto L49

def f_scale_places_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def f_scale_places_obj.__call__(__mypyc_self__, x):
    __mypyc_self__ :: faster_eth_abi.utils.numeric.f_scale_places_obj
    x :: object
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: bool
    r18, r19, r20 :: object
    r21, r22 :: tuple[object, object, object]
    r23, r24, r25 :: object
    r26 :: object[4]
    r27 :: object_ptr
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: bool
    r32 :: bit
    r33 :: object
    r34, r35 :: tuple[object, object, object]
    r36 :: object
    r37 :: tuple[object, object, object]
    r38 :: object
    r39 :: object[4]
    r40 :: object_ptr
    r41 :: object
    r42 :: bit
    r43, r44 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L37 (error at f:76) else goto L1
L1:
    r1 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r1) goto L38 else goto L4
L2:
    r2 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r2 goto L37 (error at f:77) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = decimal :: module
    r4 = 'localcontext'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L39 (error at f:77) else goto L5
L5:
    r6 = [r1]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L39 (error at f:77) else goto L6
L6:
    r9 = CPy_TYPE(r8)
    r10 = '__exit__'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L40 (error at f:77) else goto L7
L7:
    r12 = '__enter__'
    r13 = CPyObject_GetAttr(r9, r12)
    dec_ref r9
    if is_error(r13) goto L41 (error at f:77) else goto L8
L8:
    r14 = [r8]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L41 (error at f:77) else goto L42
L9:
    r17 = 1
L10:
    r18 = r0.scaling_factor
    dec_ref r0
    if is_error(r18) goto L13 (error at f:78) else goto L11
L11:
    r19 = PyNumber_Multiply(x, r18)
    dec_ref r18
    if is_error(r19) goto L13 (error at f:78) else goto L12
L12:
    r20 = r19
    goto L22
L13:
    r21 = CPy_CatchError()
    r17 = 0
    r22 = CPy_GetExcInfo()
    r23 = r22[0]
    r24 = r22[1]
    r25 = r22[2]
    dec_ref r22
    r26 = [r8, r23, r24, r25]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r11, r27, 4, 0)
    if is_error(r28) goto L43 (error at f:77) else goto L14
L14:
    dec_ref r23
    dec_ref r24
    dec_ref r25
    r29 = PyObject_IsTrue(r28)
    dec_ref r28
    r30 = r29 >= 0 :: signed
    if not r30 goto L19 (error at f:77) else goto L15 :: bool
L15:
    r31 = truncate r29: i32 to builtins.bool
    if r31 goto L18 else goto L16 :: bool
L16:
    CPy_Reraise()
    if not 0 goto L19 else goto L44 :: bool
L17:
    unreachable
L18:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    goto L21
L19:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    r32 = CPy_KeepPropagating()
    if not r32 goto L23 else goto L45 :: bool
L20:
    unreachable
L21:
    r33 = <error> :: object
    r20 = r33
L22:
    r34 = <error> :: tuple[object, object, object]
    r35 = r34
    goto L24
L23:
    r36 = <error> :: object
    r20 = r36
    r37 = CPy_CatchError()
    r35 = r37
L24:
    if r17 goto L25 else goto L46 :: bool
L25:
    r38 = load_address _Py_NoneStruct
    r39 = [r8, r38, r38, r38]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r11, r40, 4, 0)
    dec_ref r11
    if is_error(r41) goto L47 (error at f:77) else goto L48
L26:
    dec_ref r8
L27:
    if is_error(r35) goto L30 else goto L49
L28:
    CPy_Reraise()
    if not 0 goto L32 else goto L50 :: bool
L29:
    unreachable
L30:
    if is_error(r20) goto L36 else goto L31
L31:
    return r20
L32:
    if is_error(r35) goto L34 else goto L33
L33:
    CPy_RestoreExcInfo(r35)
    xdec_ref r35
L34:
    r42 = CPy_KeepPropagating()
    if not r42 goto L37 else goto L35 :: bool
L35:
    unreachable
L36:
    r43 = box(None, 1)
    inc_ref r43
    return r43
L37:
    r44 = <error> :: object
    return r44
L38:
    dec_ref r0
    goto L2
L39:
    dec_ref r0
    goto L37
L40:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    goto L37
L41:
    dec_ref r0
    dec_ref r8
    dec_ref r11
    goto L37
L42:
    dec_ref r16
    goto L9
L43:
    dec_ref r23
    dec_ref r24
    dec_ref r25
    goto L19
L44:
    dec_ref r8
    dec_ref r11
    dec_ref r21
    goto L17
L45:
    dec_ref r8
    dec_ref r11
    goto L20
L46:
    dec_ref r8
    dec_ref r11
    goto L27
L47:
    dec_ref r8
    xdec_ref r20
    goto L32
L48:
    dec_ref r41
    goto L26
L49:
    xdec_ref r20
    goto L28
L50:
    xdec_ref r35
    goto L29

def scale_places(places):
    places :: int
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bit
    r3, r4, r5 :: str
    r6 :: object
    r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12, r13 :: str
    r14, r15 :: object
    r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21 :: str
    r22 :: list
    r23, r24, r25, r26, r27, r28 :: ptr
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: str
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43, r44 :: object
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: bool
    r53 :: object
    r54 :: bool
    r55 :: int
    r56, r57 :: object
    r58 :: bool
    r59, r60 :: tuple[object, object, object]
    r61, r62, r63 :: object
    r64 :: object[4]
    r65 :: object_ptr
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: bool
    r70 :: bit
    r71, r72, r73 :: tuple[object, object, object]
    r74 :: object
    r75 :: object[4]
    r76 :: object_ptr
    r77 :: object
    r78 :: bit
    r79 :: faster_eth_abi.utils.numeric.f_scale_places_obj
    r80 :: bool
    f :: object
    r81 :: native_int
    r82 :: bit
    r83 :: native_int
    r84, r85, r86 :: bit
    r87, r88, r89, r90, r91 :: str
    r92 :: int
    r93, r94, places_repr, r95, r96, r97 :: str
    r98 :: i32
    r99 :: bit
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: object
L0:
    r0 = scale_places_env()
    if is_error(r0) goto L60 (error at scale_places:62) else goto L1
L1:
    inc_ref places :: int
    r1 = box(int, places)
    r2 = PyLong_Check(r1)
    dec_ref r1
    if r2 goto L10 else goto L61 :: bool
L2:
    r3 = ''
    r4 = 'Argument `places` must be int.  Got value '
    r5 = '{:{}}'
    inc_ref places :: int
    r6 = box(int, places)
    r7 = ''
    r8 = 'format'
    r9 = [r5, r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L62 (error at scale_places:69) else goto L3
L3:
    dec_ref r6
    r12 = ' of type '
    r13 = '{:{}}'
    inc_ref places :: int
    r14 = box(int, places)
    r15 = CPy_TYPE(r14)
    dec_ref r14
    r16 = ''
    r17 = 'format'
    r18 = [r13, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L63 (error at scale_places:70) else goto L4
L4:
    dec_ref r15
    r21 = '.'
    r22 = PyList_New(5)
    if is_error(r22) goto L64 (error at scale_places:69) else goto L5
L5:
    r23 = get_element_ptr r22 ob_item :: PyListObject
    r24 = load_mem r23 :: ptr*
    inc_ref r4
    set_mem r24, r4 :: builtins.object*
    r25 = r24 + 8
    set_mem r25, r11 :: builtins.object*
    inc_ref r12
    r26 = r24 + 16
    set_mem r26, r12 :: builtins.object*
    r27 = r24 + 24
    set_mem r27, r20 :: builtins.object*
    inc_ref r21
    r28 = r24 + 32
    set_mem r28, r21 :: builtins.object*
    r29 = PyUnicode_Join(r3, r22)
    dec_ref r22
    if is_error(r29) goto L60 (error at scale_places:69) else goto L6
L6:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L65 (error at scale_places:68) else goto L7
L7:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L65 (error at scale_places:68) else goto L8
L8:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L60 (error at scale_places:68) else goto L9 :: bool
L9:
    unreachable
L10:
    r36 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r36) goto L66 else goto L13
L11:
    r37 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r37 goto L60 (error at scale_places:73) else goto L12 :: bool
L12:
    unreachable
L13:
    r38 = decimal :: module
    r39 = 'localcontext'
    r40 = CPyObject_GetAttr(r38, r39)
    if is_error(r40) goto L67 (error at scale_places:73) else goto L14
L14:
    r41 = [r36]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r40, r42, 1, 0)
    dec_ref r40
    if is_error(r43) goto L67 (error at scale_places:73) else goto L15
L15:
    r44 = CPy_TYPE(r43)
    r45 = '__exit__'
    r46 = CPyObject_GetAttr(r44, r45)
    if is_error(r46) goto L68 (error at scale_places:73) else goto L16
L16:
    r47 = '__enter__'
    r48 = CPyObject_GetAttr(r44, r47)
    dec_ref r44
    if is_error(r48) goto L69 (error at scale_places:73) else goto L17
L17:
    r49 = [r43]
    r50 = load_address r49
    r51 = PyObject_Vectorcall(r48, r50, 1, 0)
    dec_ref r48
    if is_error(r51) goto L69 (error at scale_places:73) else goto L70
L18:
    r52 = 1
L19:
    r53 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r53) goto L20 else goto L22
L20:
    r54 = raise NameError('value for final name "TEN" was not set')
    if not r54 goto L24 (error at scale_places:74) else goto L71 :: bool
L21:
    unreachable
L22:
    r55 = CPyTagged_Negate(places)
    r56 = box(int, r55)
    r57 = CPyNumber_Power(r53, r56)
    dec_ref r56
    if is_error(r57) goto L24 (error at scale_places:74) else goto L23
L23:
    r0.scaling_factor = r57; r58 = is_error
    if not r58 goto L24 (error at scale_places:74) else goto L32 :: bool
L24:
    r59 = CPy_CatchError()
    r52 = 0
    r60 = CPy_GetExcInfo()
    r61 = r60[0]
    r62 = r60[1]
    r63 = r60[2]
    dec_ref r60
    r64 = [r43, r61, r62, r63]
    r65 = load_address r64
    r66 = PyObject_Vectorcall(r46, r65, 4, 0)
    if is_error(r66) goto L72 (error at scale_places:73) else goto L25
L25:
    dec_ref r61
    dec_ref r62
    dec_ref r63
    r67 = PyObject_IsTrue(r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L30 (error at scale_places:73) else goto L26 :: bool
L26:
    r69 = truncate r67: i32 to builtins.bool
    if r69 goto L29 else goto L27 :: bool
L27:
    CPy_Reraise()
    if not 0 goto L30 else goto L73 :: bool
L28:
    unreachable
L29:
    CPy_RestoreExcInfo(r59)
    dec_ref r59
    goto L32
L30:
    CPy_RestoreExcInfo(r59)
    dec_ref r59
    r70 = CPy_KeepPropagating()
    if not r70 goto L33 else goto L74 :: bool
L31:
    unreachable
L32:
    r71 = <error> :: tuple[object, object, object]
    r72 = r71
    goto L34
L33:
    r73 = CPy_CatchError()
    r72 = r73
L34:
    if r52 goto L35 else goto L75 :: bool
L35:
    r74 = load_address _Py_NoneStruct
    r75 = [r43, r74, r74, r74]
    r76 = load_address r75
    r77 = PyObject_Vectorcall(r46, r76, 4, 0)
    dec_ref r46
    if is_error(r77) goto L76 (error at scale_places:73) else goto L77
L36:
    dec_ref r43
L37:
    if is_error(r72) goto L44 else goto L78
L38:
    CPy_Reraise()
    if not 0 goto L40 else goto L79 :: bool
L39:
    unreachable
L40:
    if is_error(r72) goto L42 else goto L41
L41:
    CPy_RestoreExcInfo(r72)
    xdec_ref r72
L42:
    r78 = CPy_KeepPropagating()
    if not r78 goto L60 else goto L43 :: bool
L43:
    unreachable
L44:
    r79 = f_scale_places_obj()
    if is_error(r79) goto L67 (error at scale_places:76) else goto L45
L45:
    r79.__mypyc_env__ = r0; r80 = is_error
    if not r80 goto L80 (error at scale_places:76) else goto L46 :: bool
L46:
    f = r79
    r81 = places & 1
    r82 = r81 != 0
    if r82 goto L48 else goto L47 :: bool
L47:
    r83 = 0 & 1
    r84 = r83 != 0
    if r84 goto L48 else goto L49 :: bool
L48:
    r85 = CPyTagged_IsLt_(0, places)
    if r85 goto L50 else goto L53 :: bool
L49:
    r86 = places > 0 :: signed
    if r86 goto L50 else goto L53 :: bool
L50:
    r87 = 'Eneg'
    r88 = CPyTagged_Str(places)
    if is_error(r88) goto L81 (error at scale_places:80) else goto L51
L51:
    r89 = CPyStr_Build(2, r87, r88)
    dec_ref r88
    if is_error(r89) goto L81 (error at scale_places:80) else goto L52
L52:
    r90 = r89
    goto L56
L53:
    r91 = 'Epos'
    r92 = CPyTagged_Negate(places)
    r93 = CPyTagged_Str(r92)
    dec_ref r92 :: int
    if is_error(r93) goto L81 (error at scale_places:80) else goto L54
L54:
    r94 = CPyStr_Build(2, r91, r93)
    dec_ref r93
    if is_error(r94) goto L81 (error at scale_places:80) else goto L55
L55:
    r90 = r94
L56:
    places_repr = r90
    r95 = 'scale_by_'
    r96 = CPyStr_Build(2, r95, places_repr)
    dec_ref places_repr
    if is_error(r96) goto L81 (error at scale_places:81) else goto L57
L57:
    r97 = '__name__'
    r98 = PyObject_SetAttr(f, r97, r96)
    r99 = r98 >= 0 :: signed
    if not r99 goto L82 (error at scale_places:83) else goto L58 :: bool
L58:
    r100 = '__qualname__'
    r101 = PyObject_SetAttr(f, r100, r96)
    dec_ref r96
    r102 = r101 >= 0 :: signed
    if not r102 goto L81 (error at scale_places:84) else goto L59 :: bool
L59:
    return f
L60:
    r103 = <error> :: object
    return r103
L61:
    dec_ref r0
    goto L2
L62:
    dec_ref r6
    goto L60
L63:
    dec_ref r11
    dec_ref r15
    goto L60
L64:
    dec_ref r11
    dec_ref r20
    goto L60
L65:
    dec_ref r29
    goto L60
L66:
    dec_ref r0
    goto L11
L67:
    dec_ref r0
    goto L60
L68:
    dec_ref r0
    dec_ref r43
    dec_ref r44
    goto L60
L69:
    dec_ref r0
    dec_ref r43
    dec_ref r46
    goto L60
L70:
    dec_ref r51
    goto L18
L71:
    dec_ref r0
    dec_ref r43
    dec_ref r46
    goto L21
L72:
    dec_ref r61
    dec_ref r62
    dec_ref r63
    goto L30
L73:
    dec_ref r0
    dec_ref r43
    dec_ref r46
    dec_ref r59
    goto L28
L74:
    dec_ref r0
    dec_ref r43
    dec_ref r46
    goto L31
L75:
    dec_ref r43
    dec_ref r46
    goto L37
L76:
    dec_ref r0
    dec_ref r43
    goto L40
L77:
    dec_ref r77
    goto L36
L78:
    dec_ref r0
    goto L38
L79:
    xdec_ref r72
    goto L39
L80:
    dec_ref r79
    goto L60
L81:
    dec_ref f
    goto L60
L82:
    dec_ref f
    dec_ref r96
    goto L60

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: object
    r25 :: str
    r26, r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: object
    r37 :: str
    r38, r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: i32
    r46 :: bit
    r47 :: object
    r48 :: str
    r49, r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L18 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = faster_eth_abi.utils.numeric.globals :: static
    r12 = 'faster_eth_abi/utils/numeric.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L18 else goto L4 :: bool
L4:
    r15 = ('Callable', 'Final', 'Tuple')
    r16 = 'typing'
    r17 = faster_eth_abi.utils.numeric.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L18 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = faster_eth_abi.utils.numeric.globals :: static
    r20 = 'ABI_DECIMAL_PREC'
    r21 = object 999
    r22 = CPyDict_SetItem(r19, r20, r21)
    r23 = r22 >= 0 :: signed
    if not r23 goto L18 (error at <module>:8) else goto L6 :: bool
L6:
    r24 = decimal :: module
    r25 = 'Context'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L18 (error at <module>:10) else goto L7
L7:
    r27 = object 999
    r28 = [r27]
    r29 = load_address r28
    r30 = ('prec',)
    r31 = PyObject_Vectorcall(r26, r29, 0, r30)
    dec_ref r26
    if is_error(r31) goto L18 (error at <module>:10) else goto L8
L8:
    faster_eth_abi.utils.numeric.abi_decimal_context = r31 :: static
    r32 = faster_eth_abi.utils.numeric.globals :: static
    r33 = 'abi_decimal_context'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L18 (error at <module>:10) else goto L9 :: bool
L9:
    r36 = decimal :: module
    r37 = 'Decimal'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L18 (error at <module>:12) else goto L10
L10:
    r39 = object 0
    r40 = [r39]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r38, r41, 1, 0)
    dec_ref r38
    if is_error(r42) goto L18 (error at <module>:12) else goto L11
L11:
    faster_eth_abi.utils.numeric.ZERO = r42 :: static
    r43 = faster_eth_abi.utils.numeric.globals :: static
    r44 = 'ZERO'
    r45 = CPyDict_SetItem(r43, r44, r42)
    dec_ref r42
    r46 = r45 >= 0 :: signed
    if not r46 goto L18 (error at <module>:12) else goto L12 :: bool
L12:
    r47 = decimal :: module
    r48 = 'Decimal'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L18 (error at <module>:13) else goto L13
L13:
    r50 = object 10
    r51 = [r50]
    r52 = load_address r51
    r53 = PyObject_Vectorcall(r49, r52, 1, 0)
    dec_ref r49
    if is_error(r53) goto L18 (error at <module>:13) else goto L14
L14:
    faster_eth_abi.utils.numeric.TEN = r53 :: static
    r54 = faster_eth_abi.utils.numeric.globals :: static
    r55 = 'TEN'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L18 (error at <module>:13) else goto L15 :: bool
L15:
    r58 = decimal :: module
    r59 = 'Decimal'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L18 (error at <module>:15) else goto L16
L16:
    faster_eth_abi.utils.numeric.Decimal = r60 :: static
    r61 = faster_eth_abi.utils.numeric.globals :: static
    r62 = 'Decimal'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L18 (error at <module>:15) else goto L17 :: bool
L17:
    return 1
L18:
    r65 = <error> :: None
    return r65

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: bool
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: bool
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L31 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L31 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABICodec',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L31 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L31 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.abi.globals :: static
    r18 = 'registry'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L31 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.abi.globals :: static
    r21 = 'ABICodec'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L32 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L32 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.abi.default_codec = r25 :: static
    r26 = faster_eth_abi.abi.globals :: static
    r27 = 'default_codec'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L31 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.abi.default_codec :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_codec" was not set')
    if not r31 goto L31 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L31 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.abi.encode = r33 :: static
    r34 = faster_eth_abi.abi.globals :: static
    r35 = 'encode'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L31 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.abi.default_codec :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_codec" was not set')
    if not r39 goto L31 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'decode'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L31 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.abi.decode = r41 :: static
    r42 = faster_eth_abi.abi.globals :: static
    r43 = 'decode'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L31 (error at <module>:15) else goto L20 :: bool
L20:
    r46 = faster_eth_abi.abi.default_codec :: static
    if is_error(r46) goto L21 else goto L23
L21:
    r47 = raise NameError('value for final name "default_codec" was not set')
    if not r47 goto L31 (error at <module>:16) else goto L22 :: bool
L22:
    unreachable
L23:
    r48 = 'is_encodable'
    r49 = CPyObject_GetAttr(r46, r48)
    if is_error(r49) goto L31 (error at <module>:16) else goto L24
L24:
    faster_eth_abi.abi.is_encodable = r49 :: static
    r50 = faster_eth_abi.abi.globals :: static
    r51 = 'is_encodable'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L31 (error at <module>:16) else goto L25 :: bool
L25:
    r54 = faster_eth_abi.abi.default_codec :: static
    if is_error(r54) goto L26 else goto L28
L26:
    r55 = raise NameError('value for final name "default_codec" was not set')
    if not r55 goto L31 (error at <module>:17) else goto L27 :: bool
L27:
    unreachable
L28:
    r56 = 'is_encodable_type'
    r57 = CPyObject_GetAttr(r54, r56)
    if is_error(r57) goto L31 (error at <module>:17) else goto L29
L29:
    faster_eth_abi.abi.is_encodable_type = r57 :: static
    r58 = faster_eth_abi.abi.globals :: static
    r59 = 'is_encodable_type'
    r60 = CPyDict_SetItem(r58, r59, r57)
    dec_ref r57
    r61 = r60 >= 0 :: signed
    if not r61 goto L31 (error at <module>:17) else goto L30 :: bool
L30:
    return 1
L31:
    r62 = <error> :: None
    return r62
L32:
    dec_ref r19
    goto L31

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L21 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.packed.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L21 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABIEncoder',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.packed.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L21 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry_packed',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.packed.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L21 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.packed.globals :: static
    r18 = 'registry_packed'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L21 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.packed.globals :: static
    r21 = 'ABIEncoder'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L22 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L22 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.packed.default_encoder_packed = r25 :: static
    r26 = faster_eth_abi.packed.globals :: static
    r27 = 'default_encoder_packed'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L21 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r31 goto L21 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L21 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.packed.encode_packed = r33 :: static
    r34 = faster_eth_abi.packed.globals :: static
    r35 = 'encode_packed'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L21 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r39 goto L21 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'is_encodable'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L21 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.packed.is_encodable_packed = r41 :: static
    r42 = faster_eth_abi.packed.globals :: static
    r43 = 'is_encodable_packed'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L21 (error at <module>:15) else goto L20 :: bool
L20:
    return 1
L21:
    r46 = <error> :: None
    return r46
L22:
    dec_ref r19
    goto L21

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: int
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: int
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: int
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = object 115792089237316195423570985008687907853269984665640564039457584007913129639936
    r10 = faster_eth_abi.constants.globals :: static
    r11 = 'TT256'
    inc_ref r9 :: int
    r12 = box(int, r9)
    r13 = CPyDict_SetItem(r10, r11, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L8 (error at <module>:5) else goto L5 :: bool
L5:
    r15 = object 115792089237316195423570985008687907853269984665640564039457584007913129639935
    r16 = faster_eth_abi.constants.globals :: static
    r17 = 'TT256M1'
    inc_ref r15 :: int
    r18 = box(int, r15)
    r19 = CPyDict_SetItem(r16, r17, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L8 (error at <module>:6) else goto L6 :: bool
L6:
    r21 = object 57896044618658097711785492504343953926634992332820282019728792003956564819968
    r22 = faster_eth_abi.constants.globals :: static
    r23 = 'TT255'
    inc_ref r21 :: int
    r24 = box(int, r21)
    r25 = CPyDict_SetItem(r22, r23, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L8 (error at <module>:7) else goto L7 :: bool
L7:
    return 1
L8:
    r27 = <error> :: None
    return r27
